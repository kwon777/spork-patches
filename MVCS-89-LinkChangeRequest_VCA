diff --git a/mvcs-common/src/main/java/mil/navy/lcs/mvcs/common/messages/LinkSwitchMessage.java b/mvcs-common/src/main/java/mil/navy/lcs/mvcs/common/messages/LinkSwitchMessage.java
index 2aeae2a..9370cf4 100644
--- a/mvcs-common/src/main/java/mil/navy/lcs/mvcs/common/messages/LinkSwitchMessage.java
+++ b/mvcs-common/src/main/java/mil/navy/lcs/mvcs/common/messages/LinkSwitchMessage.java
@@ -18,6 +18,13 @@
       this.l1 = linkId;
    }
 
+   
+   public LinkSwitchMessage( String linkId, AcknowledgmentCategory ackCategory)
+   {
+      super(MessageCategory.LINK_ACTION, ackCategory);
+      this.l1 = linkId;
+   }
+
 
    public String getLinkId()
    {
diff --git a/mvcs-vca/src/main/java/mil/navy/lcs/mvcs/vca/snmp/agent/VehicleTable.java b/mvcs-vca/src/main/java/mil/navy/lcs/mvcs/vca/snmp/agent/VehicleTable.java
index 35ae68d..6784d36 100644
--- a/mvcs-vca/src/main/java/mil/navy/lcs/mvcs/vca/snmp/agent/VehicleTable.java
+++ b/mvcs-vca/src/main/java/mil/navy/lcs/mvcs/vca/snmp/agent/VehicleTable.java
@@ -1269,7 +1269,6 @@
     */
    public void setVehicleRequestStartRadio(SnmpTableEntry vehicleEntry, String newValue)
    {
-      LoggingManager.getPrimaryLogger().debug("Received request to start radio " + newValue);
       VehicleTableWorker.getInstance().setVehicleRequestStartRadio(newValue);
 
    }
@@ -1296,7 +1295,6 @@
     */
    public void setVehicleRequestStopRadio(SnmpTableEntry vehicleEntry, String newValue)
    {
-      LoggingManager.getPrimaryLogger().debug("Received request to stop radio " + newValue);
       VehicleTableWorker.getInstance().setVehicleRequestStopRadio(newValue);
 
    }
diff --git a/mvcs-vca/src/main/java/mil/navy/lcs/mvcs/vca/snmp/agent/workers/VehicleTableWorker.java b/mvcs-vca/src/main/java/mil/navy/lcs/mvcs/vca/snmp/agent/workers/VehicleTableWorker.java
index 9e87169..52e99a8 100644
--- a/mvcs-vca/src/main/java/mil/navy/lcs/mvcs/vca/snmp/agent/workers/VehicleTableWorker.java
+++ b/mvcs-vca/src/main/java/mil/navy/lcs/mvcs/vca/snmp/agent/workers/VehicleTableWorker.java
@@ -1,1019 +1,1027 @@
-
-
-package mil.navy.lcs.mvcs.vca.snmp.agent.workers;
-
-
-import java.util.List;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import mil.navy.lcs.mvcs.common.config.ConfigManager;
-import mil.navy.lcs.mvcs.common.config.model.Radio;
-import mil.navy.lcs.mvcs.common.config.model.Vehicle;
-import mil.navy.lcs.mvcs.common.log.LoggingManager;
-import mil.navy.lcs.mvcs.common.messages.LinkSwitchMessage;
-import mil.navy.lcs.mvcs.common.misc.ConstantValues;
-import mil.navy.lcs.mvcs.common.utils.VehicleTableUtil;
-import mil.navy.lcs.mvcs.iface.app.ExitAction;
-import mil.navy.lcs.mvcs.iface.model.node.CommsType;
-import mil.navy.lcs.mvcs.iface.model.node.ConstantValues.LinkSwitchAck;
-import mil.navy.lcs.mvcs.iface.model.node.LinkModel;
-import mil.navy.lcs.mvcs.iface.model.node.PowerConservation;
-import mil.navy.lcs.mvcs.iface.model.node.RadioLink;
-import mil.navy.lcs.mvcs.iface.model.node.VehicleNode;
-import mil.navy.lcs.mvcs.iface.power.PowerDevice;
-import mil.navy.lcs.mvcs.iface.power.PowerOutput;
-import mil.navy.lcs.mvcs.iface.rf.RFOutput;
-import mil.navy.lcs.mvcs.iface.rf.RFOutputType;
-import mil.navy.lcs.mvcs.iface.status.Status;
-import mil.navy.lcs.mvcs.vca.link.VcaLinkManager;
-import mil.navy.lcs.mvcs.vca.main.VehicleState;
-
-/**
- * This class provides functions to execute the SNMP request for vehicle table.
- * <p>
- * $LastChangedBy$ <br>
- * $LastChangedDate$ <br>
- * $LastChangedRevision$
- *
- * @version 1.0
- */
-public class VehicleTableWorker
-{
-   private static final Logger logger = LoggerFactory.getLogger(VehicleTableWorker.class);
-
-   private static volatile VehicleTableWorker instance;
-   private String vehicleId = "";
-
-   private static final String pdc_true_mapping = "ON";
-   private static final String pdc_false_mapping = "OFF";
-
-
-   private VehicleTableWorker()
-   {
-      logger.info("Initializing new instanceof: {} ", this.getClass().getName());
-      initialize();
-   }
-
-
-   public String getVehicleId()
-   {
-      return vehicleId;
-   }
-
-
-   /**
-    * Returns the single instance of the VCA request manager.
-    * 
-    * @return The single instance of the VCA request manager.
-    */
-   public static VehicleTableWorker getInstance()
-   {
-      {
-         if (instance == null)
-         {
-            synchronized (VehicleTableWorker.class)
-            {
-               if (instance == null)
-                  instance = new VehicleTableWorker();
-            }
-         }
-         return instance;
-      }
-   }
-
-
-   /**
-    * Initializes the class.
-    * 
-    * @return true if successful, false otherwise.
-    */
-   private boolean initialize()
-   {
-      try
-      {
-         vehicleId = ConfigManager.getInstance().getVehicle().getId();
-         return true;
-      }
-      catch (Exception ex)
-      {
-         return false;
-      }
-   }
-
-
-   /**
-    * To get the vehicle COMMS status.
-    * 
-    * @return "COMMS" or "NO-COMMS".
-    */
-   public String getVehicleCommsStatus()
-   {
-      VehicleNode node = VehicleState.model.node;
-
-      if (node.isComms())
-         return ConstantValues.VEHICLE_HAS_COMMS;
-      else
-         return ConstantValues.VEHICLE_HAS_NO_COMMS;
-   }
-
-
-   /**
-    * To get the requested active link of the vehicle. For RMS vehicle, it expects "LOS", "OTH",
-    * "LAN", or "".
-    * 
-    * @return - the linkId of requested active link.
-    */
-   public String getVehicleRequestedActiveLink()
-   {
-      VehicleNode node = VehicleState.model.node;
-      LinkModel link = node.getVehicleLinkRequested();
-      return link.commsType.displayName;
-   }
-
-
-   /**
-    * To request new active link for the vehicle that is initialized from VMS.
-    * 
-    * @param linkChangeValue - the link name. It may be "LOS", "OTH", "LAN" for RMS vehicle.
-    */
-   public void setVehicleRequestLinkChange(String linkChangeValue)
-   {
-      SnmpParameterParser spp = new SnmpParameterParser("setVehicleRequestLinkChange", linkChangeValue);
-      if (spp.hasError())
-      {
-         logger.error(spp.getStatusMessage());
-         return;
-      }
-
-      String radioName = spp.getValue();
-      // Handle the request with LOS, OTH, LAN instead actual radio name.
-      if (radioName != null)
-      {
-         radioName = radioName.trim();
-         if (radioName.equalsIgnoreCase("LOS"))
-         {
-            radioName = VehicleTableUtil.findLosButNotOthRadioId(vehicleId);
-         }
-         else if (radioName.equalsIgnoreCase("OTH"))
-         {
-            radioName = VehicleTableUtil.findOthRadioId(vehicleId);
-         }
-         else if (radioName.equalsIgnoreCase("LAN"))
-         {
-            radioName = VehicleTableUtil.findLanBypassLinkId(vehicleId);
-         }
-      }
-
-      // re-route the request to SCA so the SCA can decide to proceed or not.
-      VehicleState.handler.getMessageQueue().add(new LinkSwitchMessage(radioName));
-   }
-
-
-   /**
-    * This method returns the current NTP status
-    * 
-    * @return a string with SYNCED if the NTP is synced, NOT_SYNCED otherwise
-    */
-   public String getNtpStatus()
-   {
-      if (VehicleState.model.node.isNtpServerSynced())
-         return ConstantValues.SYNCED;
-      else
-         return ConstantValues.NOT_SYNCED;
-
-   }
-
-
-   /**
-    * To get the vehicle's allowed power state.
-    * 
-    * @return The allowedPowerState.
-    */
-   public String getVehicleRadioPowerStateAllowed()
-   {
-      logger.trace("Get VehicleRadioPowerStateAllowed has received.");
-
-      return String.valueOf(VehicleState.model.node.getPowerConservationMode().index);
-
-   }// end of method
-
-
-   /**
-    * To get the vehicle's allowed power state.
-    * 
-    * @param powerStateAllowed - The allowedPowerState to set.
-    */
-   public void setVehicleRadioPowerStateAllowed(String powerStateAllowed)
-   {
-      logger.trace("Set VehicleRadioPowerStateAllowed has received. powerStateAllowed:" + powerStateAllowed);
-      try
-      {
-         int powerState = Integer.parseInt(powerStateAllowed.trim());
-         if (PowerConservation.valueOf(powerState) != null)
-            VehicleState.handler.requestVehiclePowerConservation(powerState);
-         else
-            logger.error("VehicleRadioPowerStateAllowed has received an invalid power state of " + powerStateAllowed);
-      }
-      catch (Exception e)
-      {
-         LoggingManager.getPrimaryLogger().error("Error: ", e);
-      }
-   }// end of method
-
-
-   /**
-    * This method gets the current EMCON status
-    * 
-    * @return
-    */
-   public String getEmconState()
-   {
-      return VehicleState.model.node.isEmcon() ? ConstantValues.SNMP_TRUE : ConstantValues.SNMP_FALSE;
-
-   }
-
-
-   public void setEmconState(String emconState)
-   {
-      // Call this from MvcsTable
-   }
-
-
-   /**
-    * Get the current RF Switches status
-    * 
-    * @return
-    */
-   public String getMatrixSwitchMode()
-   {
-      // Get the list of radios
-      List<RadioLink> radios = (List<RadioLink>) VehicleState.model.node.getRadioLinks();
-      if (radios.size() < 1)
-         return ConstantValues.NOT_SET;
-
-      String result = "";
-
-      for (RadioLink radio : radios)
-      {
-         StringBuilder builder = new StringBuilder();
-
-         // Check what output it is using
-         for (RFOutput output : radio.getRFDevice().getRfOutputs().values())
-         {
-            String status;
-            if (output.isOutputting())
-               status = ConstantValues.ACTIVE;
-            else
-               status = ConstantValues.INACTIVE;
-
-            builder.append(radio.getLinkId()).append(",").append(output.getOutputType()).append(",").append(status).append(';');
-         }
-
-         result += builder.toString();
-      }
-
-      return result.toUpperCase();
-   }
-
-
-   public String getPdcStatus()
-   {
-      StringBuilder builder = new StringBuilder();
-
-      for (PowerDevice device : VehicleState.model.node.getPowerDevices().values())
-      {
-         for (PowerOutput output : device.getOutputs().values())
-         {
-            // PCR 1530 - Modified value to properly show power values.
-            builder.append(output.outputId).append(",").append(output.isOutputting() ? pdc_true_mapping : pdc_false_mapping).append(';');
-         }
-      }
-
-      String result = builder.toString().toUpperCase();
-
-      return result.substring(0, result.length() - 1);
-   }
-
-
-   /**
-    * To get the active link of the vehicle. It expects "LOS", "OTH", "LAN", "SAT", "BLOS" or
-    * "NONE".
-    * 
-    * @return - the linkId of active link.
-    */
-   public String getActiveLink()
-   {
-      VehicleNode node = VehicleState.model.node;
-      LinkModel link = node.getLink();
-
-      return link.commsType.displayName;
-   }
-
-
-   /**
-    * This method get the current link change status
-    * 
-    * @return the current link change status
-    */
-   public String getLinkChangeStatus()
-   {
-      return VehicleState.model.node.getLinkChangeStatus().toString().toUpperCase();
-   }
-
-
-   /**
-    * To get the power request of media converter that connects LANBYPASS
-    * 
-    * 
-    * @return "ENABLED" or "DISABLED"
-    */
-   public String getPowerOfMediaConverterForLanByPass()
-   {
-      if (VehicleState.model.node.isPowerRequestOfMediaConverter())
-         return ConstantValues.LINK_ENABLED;
-      else
-         return ConstantValues.LINK_DISABLED;
-   }
-
-
-   /**
-    * To set the power request of media converter that connects LANBYPASS
-    * 
-    * @param powerRequest - "ENABLE" or "DISABLE"
-    */
-   public void setPowerOfMediaConverterForLanByPass(String powerRequest)
-   {
-      VehicleState.handler.setMediaConverterPowerState(powerRequest);
-   }
-
-
-   /**
-    * To get antenna in use for the current active link. e.g "LOS,MAIN;LOS,MBAY". If active link is
-    * LAN or NONE, return "NOT_SET".
-    * 
-    * @return the antenna in use for active link.
-    */
-   public String getRadioAntennaInUse()
-   {
-      // Get active link
-      LinkModel link = VehicleState.model.node.getLink();
-      if (link instanceof RadioLink)
-      {
-         StringBuilder builder = new StringBuilder();
-
-         for (RFOutput output : ((RadioLink) link).getRFDevice().getRfOutputs().values())
-         {
-            // outputting
-            if (output.isOutputting())
-               builder.append(link.commsType.name()).append(",").append(output.getOutputType()).append(';');
-
-         }
-
-         return builder.toString().toUpperCase();
-      }
-
-      // not radio link
-      return ConstantValues.NOT_SET;
-
-   }// end of method
-
-
-   /**
-    * Get the current link management mode
-    * 
-    * @return a string for AUTOMATIC or MANUAL depending on the current state
-    */
-   public String getVehicleLinkManagement()
-   {
-      return VehicleState.model.node.isAutoManagement() ? ConstantValues.LINK_MANAGEMENT_MODE_AUTOMATIC : ConstantValues.LINK_MANAGEMENT_MODE_MANUAL;
-   }
-
-
-   /**
-    * 
-    * Method Description This method shutdown the vehicle
-    * 
-    * @param newValue warm or cold shutdown
-    */
-   public void setVehicleShutdown(String newValue)
-   {
-      boolean warm = newValue.equalsIgnoreCase("WARM");
-      boolean cold = newValue.equalsIgnoreCase("COLD");
-      if (warm)
-      {
-         VehicleState.handler.requestShutdown(ExitAction.WARM_SHUTDOWN);
-      }
-      else if (cold)
-      {
-         VehicleState.handler.requestShutdown(ExitAction.COLD_SHUTDOWN);
-      }
-      else
-      {
-         logger.error("Invalid Shutdown value");
-      }
-   }
-
-
-   /**
-    * To set the vehicle link management mode.
-    * 
-    * @param managementMode - the management mode to set. AUTOMATIC or MANUAL.
-    */
-   public void setVehicleRequestLinkManagement(String managementMode)
-   {
-      if (ConstantValues.LINK_MANAGEMENT_MODE_AUTOMATIC.equalsIgnoreCase(managementMode))
-         VehicleState.handler.requestAutoManagement(true);
-      else if (ConstantValues.LINK_MANAGEMENT_MODE_MANUAL.equalsIgnoreCase(managementMode))
-         VehicleState.handler.requestAutoManagement(false);
-      else
-         LoggingManager.getPrimaryLogger().error("Invalid link management mode {} to set.", managementMode);
-   }
-
-
-   /**
-    * To start the radio.
-    * 
-    * @param radio - the radio ID or radio's COMMTYPE (LOS, OTH, SAT, or BLOS)
-    */
-   public void setVehicleRequestStartRadio(String radio)
-   {
-      if (radio == null)
-         return;
-
-      radio = radio.trim();
-
-      // map the COMMTYPE to actual radio ID.
-      LinkModel link = VehicleState.model.node.getLink(radio);
-
-      // Can also be requested by the RMS display name, because LM...
-      if (link == null)
-      {
-         CommsType type = CommsType.fromDisplayName(radio);
-         link = VehicleState.model.node.getFirstLinkByCommsType(type);
-      }
-
-      if (link != null)
-         VehicleState.handler.requestInitializeLink(link.getLinkId());
-   }
-
-
-   /**
-    * To stop the radio
-    * 
-    * @param radio - the radio ID or radio's COMMTYPE (LOS, OTH, SAT, or BLOS)
-    */
-   public void setVehicleRequestStopRadio(String radio)
-   {
-      if (radio == null)
-         return;
-
-      radio = radio.trim();
-
-      // map the COMMTYPE to actual radio ID.
-      LinkModel link = VehicleState.model.node.getLink(radio);
-
-      // Can also be requested by the RMS display name, because LM...
-      if (link == null)
-      {
-         CommsType type = CommsType.fromDisplayName(radio);
-         link = VehicleState.model.node.getFirstLinkByCommsType(type);
-      }
-
-      if (link != null)
-         VehicleState.handler.requestDisconnectLink(link.getLinkId());
-   }
-
-
-   /**
-    * Method Description
-    * 
-    * THIS HAS BEEN DEPRICATED
-    * 
-    * @return
-    */
-   public String getVehicleRfTestPortStatus()
-   {
-      return ConstantValues.NOT_SET;
-
-   }
-
-
-   /**
-    * Method Description
-    * 
-    * @param newValue
-    */
-   public void setAbortLinkChange(String newValue)
-   {
-      VehicleState.handler.requestAbortLinkSwitching();
-
-   }
-
-
-   /**
-    * To get the current inhibit switch state
-    * 
-    * @return the current inhibit switch state.
-    */
-   public String getInhibitStatus()
-   {
-      if (VehicleState.model.node.isInhibited())
-         return ConstantValues.INHIBITED;
-      else
-         return ConstantValues.NOT_INHIBITED;
-   }
-
-
-   /**
-    * To set the vehicle's point-to-point radio is going to disconnect.
-    * 
-    * @param linkId - the link ID.
-    */
-   public void setVehiclePointToPointDisconnect(String linkId)
-   {
-      VehicleState.handler.requestDisconnectLink(linkId);
-   }
-
-
-   /**
-    * To get intentional Loss of COMMs status of the vehicle.
-    * 
-    * @return - "INTENTIONAL_LOC" or "".
-    */
-   public String getVehicleIntentionalLocStatus()
-   {
-      return VehicleState.model.node.isIntentionalLoc() ? "INTENTIONAL_LOC" : "";
-   }
-
-
-   /**
-    * To send request to update all mananger's status of vehicle.
-    * 
-    */
-   public void updateManagersStatusOfVehicle()
-   {
-      VehicleState.model.node.getSoftwareStatus();
-   }
-
-
-   /**
-    * To get the status of an OTH capable radio of the vehicle. This function is very ambiguous
-    * since there can be more than one OTH capable radios in the given vehicle. However, RMS folks
-    * currently has one OTH and one LOS radios. They want to know the status of radios. Defaults to
-    * ConstantValues.STATUS_UNKNOWN.
-    * 
-    * @return ConstantValues.STATUS_GOOD if link is connected. ConstantValues.STATUS_FAIL if not
-    *         connected.
-    */
-   public String getVehicleOthRadioStatus()
-   {
-      RadioLink link = (RadioLink) VehicleState.model.node.getFirstLinkByCommsType(CommsType.OTH);
-
-      if (link == null)
-         return ConstantValues.NOT_SET;
-      else
-         return link.isConnected() ? ConstantValues.STATUS_GOOD : ConstantValues.STATUS_FAILED;
-   }
-
-
-   /**
-    * To get the status of an LOS capable radio of the vehicle. This function is very ambiguous
-    * since there can be more than one LOS capable radios in the given vehicle. However, RMS folks
-    * currently has one OTH and one LOS radios. They want to know the status of radios. Defaults to
-    * ConstantValues.STATUS_UNKNOWN.
-    * 
-    * @return ConstantValues.STATUS_GOOD if link is connected. ConstantValues.STATUS_FAIL if not
-    *         connected.
-    */
-   public String getVehicleLosRadioStatus()
-   {
-      RadioLink link = (RadioLink) VehicleState.model.node.getFirstLinkByCommsType(CommsType.LOS);
-
-      if (link == null)
-         return ConstantValues.NOT_SET;
-      else
-         return link.isConnected() ? ConstantValues.STATUS_GOOD : ConstantValues.STATUS_FAILED;
-   }
-
-
-   /**
-    * To get the vehicle hardware status.
-    * 
-    * @return - The overall HW configured status. Options are "GOOD", "FAILED", or "UNKNOWN"
-    */
-   public String getVehicleHardwareStatus()
-   {
-      return VehicleState.model.node.getHardwareStatus().name();
-   }// end of method
-
-
-   /**
-    * To get the predicted LOS range of the vehicle.
-    * 
-    * @return The range of LOS radio.
-    */
-   public String getVehiclePredictedLOSRange()
-   {
-      String predictedLosRange = "0";
-
-      try
-      {
-         String losRadio = VehicleTableUtil.findLosButNotOthRadioId(vehicleId);
-
-         if (losRadio == null)
-            return predictedLosRange;
-
-         Radio losRadioConfig = (Radio) ConfigManager.getInstance().getVehicle().getLinkFromList(losRadio);
-
-         // convert the range to kiloyards
-         predictedLosRange = String.valueOf((losRadioConfig.getLosRange() * ConstantValues.NAUTICAL_MILE_IN_YDS) / 1000);
-      }
-      catch (Exception e)
-      {
-         logger.error("Error:", e);
-      }
-
-      return predictedLosRange;
-
-   }// end of method
-
-
-   /**
-    * To set the vehicle's sleep state. Expected values are "SleepAtRest", "SleepEnergized", or
-    * "Normal".
-    * 
-    * @param vehicleSleepState - The sleep state to set.
-    */
-   public void setVehicleSleepState(String vehicleSleepState)
-   {
-      logger.trace("Set vehicleSleepState has received. SleepState:" + vehicleSleepState);
-      VehicleState.handler.requestSleep(vehicleSleepState);
-
-   }// end of method
-
-
-   /**
-    * To get the vehicle's sleep state. Expected values are "SleepAtRest", "SleepEnergized", or
-    * "Normal".
-    * 
-    * @return The sleep state.
-    */
-   public String getVehicleSleepState()
-   {
-      return VehicleState.model.node.getSleepState().toString().toUpperCase();
-
-   }// end of method
-
-
-   /**
-    * To get the link switch acknowledgment.
-    * 
-    * 
-    * @return - the acknowledgment; "Yes" or "No"
-    */
-   public String getVehicleLinkSwitchAck()
-   {
-      return VehicleState.model.node.getLinkSwitchAck().toString().toUpperCase();
-
-   }
-
-
-   /**
-    * To set the link switch acknowledgment.
-    * 
-    * 
-    * @param acknowledgment - "Yes" or "No"
-    */
-   public void setVehicleLinkSwitchAck(String acknowledgment)
-   {
-      if (acknowledgment.equalsIgnoreCase(LinkSwitchAck.YES.toString()))
-         VehicleState.handler.setLinkSwitchAck(LinkSwitchAck.YES.toString());
-      else
-         VehicleState.handler.setLinkSwitchAck(LinkSwitchAck.NO.toString());
-
-   }// end of method
-
-
-   /**
-    * To set the on board.
-    * 
-    * @param onBoard - onBoard to set.
-    */
-   public void setVehicleOnBoard(String onBoard)
-   {
-      VehicleState.handler.requestVehicleDeployStatus(onBoard);
-   }// end of method
-
-
-   /**
-    * To set the link on board.
-    * 
-    * @return The onBoard
-    */
-   public String getVehicleOnBoard()
-   {
-      if (VehicleState.model.node.isDeployed())
-         return ConstantValues.VehicleInWater.InWater.toString().toUpperCase();
-      else
-         return ConstantValues.VehicleInWater.NotInWater.toString().toUpperCase();
-
-   }// end of method
-
-
-   /**
-    * To set the vehicle's power state of LOS radio power amplifier.
-    * 
-    * @param powerState - powerState to set. "ON" or "OFF"
-    */
-   public void setVehicleLosPAPowerState(String powerState)
-   {
-      VehicleState.handler.setLosAmpPowerStatus(powerState);
-
-   }// end of method
-
-
-   /**
-    * To get the vehicle's power state of LOS radio power amplifier.
-    * 
-    * @return The powerState.
-    */
-   public String getVehicleLosPAPowerState()
-   {
-      if (VehicleState.model.node.isLosAmpPowerOn())
-         return ConstantValues.POWERED_ON;
-      else
-         return ConstantValues.POWERED_OFF;
-
-   }// end of method
-
-
-   /**
-    * Method Description
-    * 
-    * @param vehicleId
-    * @return
-    */
-   public String getVehicleNetworkStatus(String vehicleId)
-   {
-      if (VehicleState.model.node.isComms())
-         return ConstantValues.HARDWARE_STATUS_GO;
-      else
-         return ConstantValues.HARDWARE_STATUS_NO_GO;
-   }
-
-
-   /**
-    * Method Description
-    * 
-    * @param vehicleId
-    * @return
-    */
-   public String getVehicleIpAddress(String vehicleId)
-   {
-      return ConfigManager.getInstance().getVehicle().getIpAddress();
-   }
-
-
-   /**
-    * Method Description
-    * 
-    * @param vehicleName
-    * @return
-    */
-   public String getVehicleRfLosSwitchOneStatus(String vehicleName)
-   {
-      return ConstantValues.NOT_SET;
-   }
-
-
-   /**
-    * Method Description
-    * 
-    * @param vehicleName
-    * @return
-    */
-   public String getVehicleRfLosSwitchThreeStatus(String vehicleName)
-   {
-      return ConstantValues.NOT_SET;
-   }
-
-
-   /**
-    * Method Description
-    * 
-    * @param vehicleName
-    * @return
-    */
-   public String getVehicleRfOthSwitchThreeStatus(String vehicleName)
-   {
-      return ConstantValues.NOT_SET;
-   }
-
-
-   /**
-    * TODO: Change call to Model Class - RF Switches
-    * 
-    * @param vehicleName
-    * @return
-    */
-   public String getVehicleRfOthSwitchTwoStatus(String vehicleName)
-   {
-      return ConstantValues.NOT_SET;
-   }
-
-
-   /**
-    * To get the LOS Power Amp's power request.
-    * 
-    * @return - The power request. On or Off
-    */
-   public String getLosPaPowerRequest()
-   {
-      if (VehicleState.model.node.isLosAmpPowerRequested())
-         return ConstantValues.POWERED_ON;
-      else
-         return ConstantValues.POWERED_OFF;
-   }
-
-
-   /**
-    * Gets the predictedOthRange.
-    * 
-    * @return predictedOthRange
-    */
-   public String getPredictedOthRange()
-   {
-      String range = "0";
-
-      try
-      {
-         Vehicle vehicle = ConfigManager.getInstance().getVehicle();
-
-         Integer maxRange = 0;
-         for (Radio radio : vehicle.getListOfRadios())
-            if (radio.getRadioCharacteristics().isOthCapable())
-               maxRange = Math.max(maxRange, radio.getLosRange());
-
-         // convert the range to kiloyards
-         range = String.valueOf((maxRange * ConstantValues.NAUTICAL_MILE_IN_YDS) / 1000);
-      }
-      catch (Exception e)
-      {
-         LoggingManager.getSystemErrorLogger().error("Exception while getting OTH range: ", e);
-      }
-
-      return range;
-   }
-
-
-   /**
-    * To get vehicle altitude depth.
-    * 
-    * @return the altitude depth.
-    */
-   public String getVehicleAltitudeDepth()
-   {
-      return String.valueOf(VehicleState.model.node.getDepth());
-   }
-
-
-   /**
-    * To set vehicle altitude depth.
-    */
-   public void setVehicleAltitudeDepth(String depth)
-   {
-      VehicleState.handler.setAltitudeDepth(Double.parseDouble(depth));
-
-   }
-
-
-   /**
-    * To get vehicle GPS latitude.
-    * 
-    * @return the GPS latitude.
-    */
-   public String getVehicleGPSLatitude()
-   {
-      return String.valueOf(VehicleState.model.node.getLatitude());
-   }
-
-
-   /**
-    * To set vehicle GPS latitude.
-    * 
-    * @param latitude the GPS latitude.
-    */
-   public void setVehicleGPSLatitude(String latitude)
-   {
-      VehicleState.handler.setGpsLatitude(Double.parseDouble(latitude));
-
-   }
-
-
-   /**
-    * To get vehicle GPS longitude.
-    * 
-    * @return the GPS longitude.
-    */
-   public String getVehicleGPSLongitude()
-   {
-      return String.valueOf(VehicleState.model.node.getLongitude());
-   }
-
-
-   /**
-    * To set vehicle GPS longitude.
-    * 
-    * TODO: Move code to handler
-    * 
-    * @param longitude the GPS longitude.
-    */
-   public void setVehicleGPSLongitude(String longitude)
-   {
-      VehicleState.handler.setGpsLongitude(Double.parseDouble(longitude));
-
-   }
-
-
-   /**
-    * Get the current system status
-    * 
-    * @return GO if system is up, NO_GO otherwise
-    */
-   public String getMvcsSystemStatus()
-   {
-      Status s = VehicleState.model.node.getHardwareStatus();
-
-      if (s == Status.GOOD)
-         return ConstantValues.HARDWARE_STATUS_GO;
-      else
-         return ConstantValues.HARDWARE_STATUS_NO_GO;
-   }
-
-
-   /**
-    * Sets RF switch input and output mode. Values are "RADIO,RF_OUTPUT". Values for RADIO are "LOS"
-    * and "OTH". Values for RFOUTPUT are RFOutputType such as "LNR", "MAIN", "MBAY", "TEST",
-    * "TEST_MAIN", and "TEST_LNR".
-    * 
-    * @param radioRfoutput - the value to change RF switch.
-    */
-   public void setVehicleRequestMatrixSwitchMode(String radioRfoutput)
-   {
-      try
-      {
-         logger.debug("External request to set RF switch [Mode:{}]");
-         
-         // IR-2017-0176 Block external commands during LOCR
-         if(VcaLinkManager.getInstance().getVcaNodeBean().isInAutoLocRecovery())
-         {
-            // Not allow antenna change. Let the LOCR do the work.
-            logger.info("External command is blocked because the LOC-recovery is in progress.");
-            return;
-         }
-
-         String[] params = radioRfoutput.split(",");
-         if (params.length != 2)
-         {
-            LoggingManager.getPrimaryLogger().error("Invalid value {} to change RF switch.", radioRfoutput);
-            return;
-         }
-
-         CommsType commsType = CommsType.valueOf(params[0].trim());
-         RFOutputType rfOutputType = RFOutputType.valueOf(params[1].trim());
-
-         LinkModel link = VehicleState.model.node.getFirstLinkByCommsType(commsType);
-         VehicleState.handler.requestRf(link.getLinkId(), rfOutputType, true);
-      }
-      catch (Exception e)
-      {
-         LoggingManager.getPrimaryLogger().error("Error change matrix switch mode: ", e);
-      }
-   }
-
-
-   /**
-    * To get the vehicle zeroized status.
-    * 
-    * @return "TRUE" if keyed otherwise returns "FALSE".
-    */
-   public String getVehicleZeroized()
-   {
-      return VehicleState.model.node.isKeyed() ? "FALSE" : "TRUE";
-   }
-
-
-   /**
-    * To set the vehicle zeroized status.
-    * 
-    * @param zeroize - "TRUE" to set zeroized otherwise ignored.
-    */
-   public void setVehicleZeroized(String zeroize)
-   {
-      if (Boolean.parseBoolean(zeroize))
-         VehicleState.handler.requestZeroize();
-   }
-
-}// end of class
+
+
+package mil.navy.lcs.mvcs.vca.snmp.agent.workers;
+
+
+import java.util.List;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import mil.navy.lcs.mvcs.common.config.ConfigManager;
+import mil.navy.lcs.mvcs.common.config.model.Radio;
+import mil.navy.lcs.mvcs.common.config.model.Vehicle;
+import mil.navy.lcs.mvcs.common.log.LoggingManager;
+import mil.navy.lcs.mvcs.common.messages.AcknowledgmentCategory;
+import mil.navy.lcs.mvcs.common.messages.LinkSwitchMessage;
+import mil.navy.lcs.mvcs.common.misc.ConstantValues;
+import mil.navy.lcs.mvcs.common.utils.VehicleTableUtil;
+import mil.navy.lcs.mvcs.iface.app.ExitAction;
+import mil.navy.lcs.mvcs.iface.model.node.CommsType;
+import mil.navy.lcs.mvcs.iface.model.node.ConstantValues.LinkSwitchAck;
+import mil.navy.lcs.mvcs.iface.model.node.LinkModel;
+import mil.navy.lcs.mvcs.iface.model.node.PowerConservation;
+import mil.navy.lcs.mvcs.iface.model.node.RadioLink;
+import mil.navy.lcs.mvcs.iface.model.node.VehicleNode;
+import mil.navy.lcs.mvcs.iface.power.PowerDevice;
+import mil.navy.lcs.mvcs.iface.power.PowerOutput;
+import mil.navy.lcs.mvcs.iface.rf.RFOutput;
+import mil.navy.lcs.mvcs.iface.rf.RFOutputType;
+import mil.navy.lcs.mvcs.iface.status.Status;
+import mil.navy.lcs.mvcs.vca.link.VcaLinkManager;
+import mil.navy.lcs.mvcs.vca.main.VehicleState;
+
+/**
+ * This class provides functions to execute the SNMP request for vehicle table.
+ * <p>
+ * $LastChangedBy$ <br>
+ * $LastChangedDate$ <br>
+ * $LastChangedRevision$
+ *
+ * @version 1.0
+ */
+public class VehicleTableWorker
+{
+   private static final Logger logger = LoggerFactory.getLogger(VehicleTableWorker.class);
+
+   private static volatile VehicleTableWorker instance;
+   private String vehicleId = "";
+
+   private static final String pdc_true_mapping = "ON";
+   private static final String pdc_false_mapping = "OFF";
+
+
+   private VehicleTableWorker()
+   {
+      logger.info("Initializing new instanceof: {} ", this.getClass().getName());
+      initialize();
+   }
+
+
+   public String getVehicleId()
+   {
+      return vehicleId;
+   }
+
+
+   /**
+    * Returns the single instance of the VCA request manager.
+    * 
+    * @return The single instance of the VCA request manager.
+    */
+   public static VehicleTableWorker getInstance()
+   {
+      {
+         if (instance == null)
+         {
+            synchronized (VehicleTableWorker.class)
+            {
+               if (instance == null)
+                  instance = new VehicleTableWorker();
+            }
+         }
+         return instance;
+      }
+   }
+
+
+   /**
+    * Initializes the class.
+    * 
+    * @return true if successful, false otherwise.
+    */
+   private boolean initialize()
+   {
+      try
+      {
+         vehicleId = ConfigManager.getInstance().getVehicle().getId();
+         return true;
+      }
+      catch (Exception ex)
+      {
+         return false;
+      }
+   }
+
+
+   /**
+    * To get the vehicle COMMS status.
+    * 
+    * @return "COMMS" or "NO-COMMS".
+    */
+   public String getVehicleCommsStatus()
+   {
+      VehicleNode node = VehicleState.model.node;
+
+      if (node.isComms())
+         return ConstantValues.VEHICLE_HAS_COMMS;
+      else
+         return ConstantValues.VEHICLE_HAS_NO_COMMS;
+   }
+
+
+   /**
+    * To get the requested active link of the vehicle. For RMS vehicle, it expects "LOS", "OTH",
+    * "LAN", or "".
+    * 
+    * @return - the linkId of requested active link.
+    */
+   public String getVehicleRequestedActiveLink()
+   {
+      VehicleNode node = VehicleState.model.node;
+      LinkModel link = node.getVehicleLinkRequested();
+      return link.commsType.displayName;
+   }
+
+
+   /**
+    * To request new active link for the vehicle that is initialized from VMS. This request shall be
+    * re-directed to the host system (SCA) for a confirmation. The request message should only be
+    * attempted to transmit to the host system once without any further retransmit to avoid delayed
+    * unexpected behavior.
+    * 
+    * @param linkChangeValue - the link name. It may be "LOS", "OTH", "LAN" for RMS vehicle.
+    */
+   public void setVehicleRequestLinkChange(String linkChangeValue)
+   {
+      logger.debug("External request to change link to [Link:{}]", linkChangeValue);
+      SnmpParameterParser spp = new SnmpParameterParser("setVehicleRequestLinkChange", linkChangeValue);
+      if (spp.hasError())
+      {
+         logger.error(spp.getStatusMessage());
+         return;
+      }
+
+      String radioName = spp.getValue();
+      // Handle the request with LOS, OTH, LAN instead actual radio name.
+      if (radioName != null)
+      {
+         radioName = radioName.trim();
+         if (radioName.equalsIgnoreCase("LOS"))
+         {
+            radioName = VehicleTableUtil.findLosButNotOthRadioId(vehicleId);
+         }
+         else if (radioName.equalsIgnoreCase("OTH"))
+         {
+            radioName = VehicleTableUtil.findOthRadioId(vehicleId);
+         }
+         else if (radioName.equalsIgnoreCase("LAN"))
+         {
+            radioName = VehicleTableUtil.findLanBypassLinkId(vehicleId);
+         }
+      }
+
+      // re-route the request to SCA so the SCA can decide to proceed or not.
+      // Should not be re-transmitted after initial attempt to avoid delayed action
+      VehicleState.handler.getMessageQueue().add(new LinkSwitchMessage(radioName, AcknowledgmentCategory.NO_ACK_NO_RETRY));
+   }
+
+
+   /**
+    * This method returns the current NTP status
+    * 
+    * @return a string with SYNCED if the NTP is synced, NOT_SYNCED otherwise
+    */
+   public String getNtpStatus()
+   {
+      if (VehicleState.model.node.isNtpServerSynced())
+         return ConstantValues.SYNCED;
+      else
+         return ConstantValues.NOT_SYNCED;
+
+   }
+
+
+   /**
+    * To get the vehicle's allowed power state.
+    * 
+    * @return The allowedPowerState.
+    */
+   public String getVehicleRadioPowerStateAllowed()
+   {
+      logger.trace("Get VehicleRadioPowerStateAllowed has received.");
+
+      return String.valueOf(VehicleState.model.node.getPowerConservationMode().index);
+
+   }// end of method
+
+
+   /**
+    * To get the vehicle's allowed power state.
+    * 
+    * @param powerStateAllowed - The allowedPowerState to set.
+    */
+   public void setVehicleRadioPowerStateAllowed(String powerStateAllowed)
+   {
+      logger.trace("Set VehicleRadioPowerStateAllowed has received. powerStateAllowed:" + powerStateAllowed);
+      try
+      {
+         int powerState = Integer.parseInt(powerStateAllowed.trim());
+         if (PowerConservation.valueOf(powerState) != null)
+            VehicleState.handler.requestVehiclePowerConservation(powerState);
+         else
+            logger.error("VehicleRadioPowerStateAllowed has received an invalid power state of " + powerStateAllowed);
+      }
+      catch (Exception e)
+      {
+         LoggingManager.getPrimaryLogger().error("Error: ", e);
+      }
+   }// end of method
+
+
+   /**
+    * This method gets the current EMCON status
+    * 
+    * @return
+    */
+   public String getEmconState()
+   {
+      return VehicleState.model.node.isEmcon() ? ConstantValues.SNMP_TRUE : ConstantValues.SNMP_FALSE;
+
+   }
+
+
+   public void setEmconState(String emconState)
+   {
+      // Call this from MvcsTable
+   }
+
+
+   /**
+    * Get the current RF Switches status
+    * 
+    * @return
+    */
+   public String getMatrixSwitchMode()
+   {
+      // Get the list of radios
+      List<RadioLink> radios = (List<RadioLink>) VehicleState.model.node.getRadioLinks();
+      if (radios.size() < 1)
+         return ConstantValues.NOT_SET;
+
+      String result = "";
+
+      for (RadioLink radio : radios)
+      {
+         StringBuilder builder = new StringBuilder();
+
+         // Check what output it is using
+         for (RFOutput output : radio.getRFDevice().getRfOutputs().values())
+         {
+            String status;
+            if (output.isOutputting())
+               status = ConstantValues.ACTIVE;
+            else
+               status = ConstantValues.INACTIVE;
+
+            builder.append(radio.getLinkId()).append(",").append(output.getOutputType()).append(",").append(status).append(';');
+         }
+
+         result += builder.toString();
+      }
+
+      return result.toUpperCase();
+   }
+
+
+   public String getPdcStatus()
+   {
+      StringBuilder builder = new StringBuilder();
+
+      for (PowerDevice device : VehicleState.model.node.getPowerDevices().values())
+      {
+         for (PowerOutput output : device.getOutputs().values())
+         {
+            // PCR 1530 - Modified value to properly show power values.
+            builder.append(output.outputId).append(",").append(output.isOutputting() ? pdc_true_mapping : pdc_false_mapping).append(';');
+         }
+      }
+
+      String result = builder.toString().toUpperCase();
+
+      return result.substring(0, result.length() - 1);
+   }
+
+
+   /**
+    * To get the active link of the vehicle. It expects "LOS", "OTH", "LAN", "SAT", "BLOS" or
+    * "NONE".
+    * 
+    * @return - the linkId of active link.
+    */
+   public String getActiveLink()
+   {
+      VehicleNode node = VehicleState.model.node;
+      LinkModel link = node.getLink();
+
+      return link.commsType.displayName;
+   }
+
+
+   /**
+    * This method get the current link change status
+    * 
+    * @return the current link change status
+    */
+   public String getLinkChangeStatus()
+   {
+      return VehicleState.model.node.getLinkChangeStatus().toString().toUpperCase();
+   }
+
+
+   /**
+    * To get the power request of media converter that connects LANBYPASS
+    * 
+    * 
+    * @return "ENABLED" or "DISABLED"
+    */
+   public String getPowerOfMediaConverterForLanByPass()
+   {
+      if (VehicleState.model.node.isPowerRequestOfMediaConverter())
+         return ConstantValues.LINK_ENABLED;
+      else
+         return ConstantValues.LINK_DISABLED;
+   }
+
+
+   /**
+    * To set the power request of media converter that connects LANBYPASS
+    * 
+    * @param powerRequest - "ENABLE" or "DISABLE"
+    */
+   public void setPowerOfMediaConverterForLanByPass(String powerRequest)
+   {
+      VehicleState.handler.setMediaConverterPowerState(powerRequest);
+   }
+
+
+   /**
+    * To get antenna in use for the current active link. e.g "LOS,MAIN;LOS,MBAY". If active link is
+    * LAN or NONE, return "NOT_SET".
+    * 
+    * @return the antenna in use for active link.
+    */
+   public String getRadioAntennaInUse()
+   {
+      // Get active link
+      LinkModel link = VehicleState.model.node.getLink();
+      if (link instanceof RadioLink)
+      {
+         StringBuilder builder = new StringBuilder();
+
+         for (RFOutput output : ((RadioLink) link).getRFDevice().getRfOutputs().values())
+         {
+            // outputting
+            if (output.isOutputting())
+               builder.append(link.commsType.name()).append(",").append(output.getOutputType()).append(';');
+
+         }
+
+         return builder.toString().toUpperCase();
+      }
+
+      // not radio link
+      return ConstantValues.NOT_SET;
+
+   }// end of method
+
+
+   /**
+    * Get the current link management mode
+    * 
+    * @return a string for AUTOMATIC or MANUAL depending on the current state
+    */
+   public String getVehicleLinkManagement()
+   {
+      return VehicleState.model.node.isAutoManagement() ? ConstantValues.LINK_MANAGEMENT_MODE_AUTOMATIC : ConstantValues.LINK_MANAGEMENT_MODE_MANUAL;
+   }
+
+
+   /**
+    * 
+    * Method Description This method shutdown the vehicle
+    * 
+    * @param newValue warm or cold shutdown
+    */
+   public void setVehicleShutdown(String newValue)
+   {
+      boolean warm = newValue.equalsIgnoreCase("WARM");
+      boolean cold = newValue.equalsIgnoreCase("COLD");
+      if (warm)
+      {
+         VehicleState.handler.requestShutdown(ExitAction.WARM_SHUTDOWN);
+      }
+      else if (cold)
+      {
+         VehicleState.handler.requestShutdown(ExitAction.COLD_SHUTDOWN);
+      }
+      else
+      {
+         logger.error("Invalid Shutdown value");
+      }
+   }
+
+
+   /**
+    * To set the vehicle link management mode.
+    * 
+    * @param managementMode - the management mode to set. AUTOMATIC or MANUAL.
+    */
+   public void setVehicleRequestLinkManagement(String managementMode)
+   {
+      if (ConstantValues.LINK_MANAGEMENT_MODE_AUTOMATIC.equalsIgnoreCase(managementMode))
+         VehicleState.handler.requestAutoManagement(true);
+      else if (ConstantValues.LINK_MANAGEMENT_MODE_MANUAL.equalsIgnoreCase(managementMode))
+         VehicleState.handler.requestAutoManagement(false);
+      else
+         LoggingManager.getPrimaryLogger().error("Invalid link management mode {} to set.", managementMode);
+   }
+
+
+   /**
+    * To start the radio.
+    * 
+    * @param radio - the radio ID or radio's COMMTYPE (LOS, OTH, SAT, or BLOS)
+    */
+   public void setVehicleRequestStartRadio(String radio)
+   {
+      logger.debug("External request to start radio [Radio:{}]" + radio);
+      if (radio == null)
+         return;
+
+      radio = radio.trim();
+
+      // map the COMMTYPE to actual radio ID.
+      LinkModel link = VehicleState.model.node.getLink(radio);
+
+      // Can also be requested by the RMS display name, because LM...
+      if (link == null)
+      {
+         CommsType type = CommsType.fromDisplayName(radio);
+         link = VehicleState.model.node.getFirstLinkByCommsType(type);
+      }
+
+      if (link != null)
+         VehicleState.handler.requestInitializeLink(link.getLinkId());
+   }
+
+
+   /**
+    * To stop the radio
+    * 
+    * @param radio - the radio ID or radio's COMMTYPE (LOS, OTH, SAT, or BLOS)
+    */
+   public void setVehicleRequestStopRadio(String radio)
+   {
+      logger.debug("External request to stop radio [Radio:{}]" + radio);
+      if (radio == null)
+         return;
+
+      radio = radio.trim();
+
+      // map the COMMTYPE to actual radio ID.
+      LinkModel link = VehicleState.model.node.getLink(radio);
+
+      // Can also be requested by the RMS display name, because LM...
+      if (link == null)
+      {
+         CommsType type = CommsType.fromDisplayName(radio);
+         link = VehicleState.model.node.getFirstLinkByCommsType(type);
+      }
+
+      if (link != null)
+         VehicleState.handler.requestDisconnectLink(link.getLinkId());
+   }
+
+
+   /**
+    * Method Description
+    * 
+    * THIS HAS BEEN DEPRICATED
+    * 
+    * @return
+    */
+   public String getVehicleRfTestPortStatus()
+   {
+      return ConstantValues.NOT_SET;
+
+   }
+
+
+   /**
+    * Method Description
+    * 
+    * @param newValue
+    */
+   public void setAbortLinkChange(String newValue)
+   {
+      VehicleState.handler.requestAbortLinkSwitching();
+
+   }
+
+
+   /**
+    * To get the current inhibit switch state
+    * 
+    * @return the current inhibit switch state.
+    */
+   public String getInhibitStatus()
+   {
+      if (VehicleState.model.node.isInhibited())
+         return ConstantValues.INHIBITED;
+      else
+         return ConstantValues.NOT_INHIBITED;
+   }
+
+
+   /**
+    * To set the vehicle's point-to-point radio is going to disconnect.
+    * 
+    * @param linkId - the link ID.
+    */
+   public void setVehiclePointToPointDisconnect(String linkId)
+   {
+      VehicleState.handler.requestDisconnectLink(linkId);
+   }
+
+
+   /**
+    * To get intentional Loss of COMMs status of the vehicle.
+    * 
+    * @return - "INTENTIONAL_LOC" or "".
+    */
+   public String getVehicleIntentionalLocStatus()
+   {
+      return VehicleState.model.node.isIntentionalLoc() ? "INTENTIONAL_LOC" : "";
+   }
+
+
+   /**
+    * To send request to update all mananger's status of vehicle.
+    * 
+    */
+   public void updateManagersStatusOfVehicle()
+   {
+      VehicleState.model.node.getSoftwareStatus();
+   }
+
+
+   /**
+    * To get the status of an OTH capable radio of the vehicle. This function is very ambiguous
+    * since there can be more than one OTH capable radios in the given vehicle. However, RMS folks
+    * currently has one OTH and one LOS radios. They want to know the status of radios. Defaults to
+    * ConstantValues.STATUS_UNKNOWN.
+    * 
+    * @return ConstantValues.STATUS_GOOD if link is connected. ConstantValues.STATUS_FAIL if not
+    *         connected.
+    */
+   public String getVehicleOthRadioStatus()
+   {
+      RadioLink link = (RadioLink) VehicleState.model.node.getFirstLinkByCommsType(CommsType.OTH);
+
+      if (link == null)
+         return ConstantValues.NOT_SET;
+      else
+         return link.isConnected() ? ConstantValues.STATUS_GOOD : ConstantValues.STATUS_FAILED;
+   }
+
+
+   /**
+    * To get the status of an LOS capable radio of the vehicle. This function is very ambiguous
+    * since there can be more than one LOS capable radios in the given vehicle. However, RMS folks
+    * currently has one OTH and one LOS radios. They want to know the status of radios. Defaults to
+    * ConstantValues.STATUS_UNKNOWN.
+    * 
+    * @return ConstantValues.STATUS_GOOD if link is connected. ConstantValues.STATUS_FAIL if not
+    *         connected.
+    */
+   public String getVehicleLosRadioStatus()
+   {
+      RadioLink link = (RadioLink) VehicleState.model.node.getFirstLinkByCommsType(CommsType.LOS);
+
+      if (link == null)
+         return ConstantValues.NOT_SET;
+      else
+         return link.isConnected() ? ConstantValues.STATUS_GOOD : ConstantValues.STATUS_FAILED;
+   }
+
+
+   /**
+    * To get the vehicle hardware status.
+    * 
+    * @return - The overall HW configured status. Options are "GOOD", "FAILED", or "UNKNOWN"
+    */
+   public String getVehicleHardwareStatus()
+   {
+      return VehicleState.model.node.getHardwareStatus().name();
+   }// end of method
+
+
+   /**
+    * To get the predicted LOS range of the vehicle.
+    * 
+    * @return The range of LOS radio.
+    */
+   public String getVehiclePredictedLOSRange()
+   {
+      String predictedLosRange = "0";
+
+      try
+      {
+         String losRadio = VehicleTableUtil.findLosButNotOthRadioId(vehicleId);
+
+         if (losRadio == null)
+            return predictedLosRange;
+
+         Radio losRadioConfig = (Radio) ConfigManager.getInstance().getVehicle().getLinkFromList(losRadio);
+
+         // convert the range to kiloyards
+         predictedLosRange = String.valueOf((losRadioConfig.getLosRange() * ConstantValues.NAUTICAL_MILE_IN_YDS) / 1000);
+      }
+      catch (Exception e)
+      {
+         logger.error("Error:", e);
+      }
+
+      return predictedLosRange;
+
+   }// end of method
+
+
+   /**
+    * To set the vehicle's sleep state. Expected values are "SleepAtRest", "SleepEnergized", or
+    * "Normal".
+    * 
+    * @param vehicleSleepState - The sleep state to set.
+    */
+   public void setVehicleSleepState(String vehicleSleepState)
+   {
+      logger.trace("Set vehicleSleepState has received. SleepState:" + vehicleSleepState);
+      VehicleState.handler.requestSleep(vehicleSleepState);
+
+   }// end of method
+
+
+   /**
+    * To get the vehicle's sleep state. Expected values are "SleepAtRest", "SleepEnergized", or
+    * "Normal".
+    * 
+    * @return The sleep state.
+    */
+   public String getVehicleSleepState()
+   {
+      return VehicleState.model.node.getSleepState().toString().toUpperCase();
+
+   }// end of method
+
+
+   /**
+    * To get the link switch acknowledgment.
+    * 
+    * 
+    * @return - the acknowledgment; "Yes" or "No"
+    */
+   public String getVehicleLinkSwitchAck()
+   {
+      return VehicleState.model.node.getLinkSwitchAck().toString().toUpperCase();
+
+   }
+
+
+   /**
+    * To set the link switch acknowledgment.
+    * 
+    * 
+    * @param acknowledgment - "Yes" or "No"
+    */
+   public void setVehicleLinkSwitchAck(String acknowledgment)
+   {
+      if (acknowledgment.equalsIgnoreCase(LinkSwitchAck.YES.toString()))
+         VehicleState.handler.setLinkSwitchAck(LinkSwitchAck.YES.toString());
+      else
+         VehicleState.handler.setLinkSwitchAck(LinkSwitchAck.NO.toString());
+
+   }// end of method
+
+
+   /**
+    * To set the on board.
+    * 
+    * @param onBoard - onBoard to set.
+    */
+   public void setVehicleOnBoard(String onBoard)
+   {
+      VehicleState.handler.requestVehicleDeployStatus(onBoard);
+   }// end of method
+
+
+   /**
+    * To set the link on board.
+    * 
+    * @return The onBoard
+    */
+   public String getVehicleOnBoard()
+   {
+      if (VehicleState.model.node.isDeployed())
+         return ConstantValues.VehicleInWater.InWater.toString().toUpperCase();
+      else
+         return ConstantValues.VehicleInWater.NotInWater.toString().toUpperCase();
+
+   }// end of method
+
+
+   /**
+    * To set the vehicle's power state of LOS radio power amplifier.
+    * 
+    * @param powerState - powerState to set. "ON" or "OFF"
+    */
+   public void setVehicleLosPAPowerState(String powerState)
+   {
+      VehicleState.handler.setLosAmpPowerStatus(powerState);
+
+   }// end of method
+
+
+   /**
+    * To get the vehicle's power state of LOS radio power amplifier.
+    * 
+    * @return The powerState.
+    */
+   public String getVehicleLosPAPowerState()
+   {
+      if (VehicleState.model.node.isLosAmpPowerOn())
+         return ConstantValues.POWERED_ON;
+      else
+         return ConstantValues.POWERED_OFF;
+
+   }// end of method
+
+
+   /**
+    * Method Description
+    * 
+    * @param vehicleId
+    * @return
+    */
+   public String getVehicleNetworkStatus(String vehicleId)
+   {
+      if (VehicleState.model.node.isComms())
+         return ConstantValues.HARDWARE_STATUS_GO;
+      else
+         return ConstantValues.HARDWARE_STATUS_NO_GO;
+   }
+
+
+   /**
+    * Method Description
+    * 
+    * @param vehicleId
+    * @return
+    */
+   public String getVehicleIpAddress(String vehicleId)
+   {
+      return ConfigManager.getInstance().getVehicle().getIpAddress();
+   }
+
+
+   /**
+    * Method Description
+    * 
+    * @param vehicleName
+    * @return
+    */
+   public String getVehicleRfLosSwitchOneStatus(String vehicleName)
+   {
+      return ConstantValues.NOT_SET;
+   }
+
+
+   /**
+    * Method Description
+    * 
+    * @param vehicleName
+    * @return
+    */
+   public String getVehicleRfLosSwitchThreeStatus(String vehicleName)
+   {
+      return ConstantValues.NOT_SET;
+   }
+
+
+   /**
+    * Method Description
+    * 
+    * @param vehicleName
+    * @return
+    */
+   public String getVehicleRfOthSwitchThreeStatus(String vehicleName)
+   {
+      return ConstantValues.NOT_SET;
+   }
+
+
+   /**
+    * TODO: Change call to Model Class - RF Switches
+    * 
+    * @param vehicleName
+    * @return
+    */
+   public String getVehicleRfOthSwitchTwoStatus(String vehicleName)
+   {
+      return ConstantValues.NOT_SET;
+   }
+
+
+   /**
+    * To get the LOS Power Amp's power request.
+    * 
+    * @return - The power request. On or Off
+    */
+   public String getLosPaPowerRequest()
+   {
+      if (VehicleState.model.node.isLosAmpPowerRequested())
+         return ConstantValues.POWERED_ON;
+      else
+         return ConstantValues.POWERED_OFF;
+   }
+
+
+   /**
+    * Gets the predictedOthRange.
+    * 
+    * @return predictedOthRange
+    */
+   public String getPredictedOthRange()
+   {
+      String range = "0";
+
+      try
+      {
+         Vehicle vehicle = ConfigManager.getInstance().getVehicle();
+
+         Integer maxRange = 0;
+         for (Radio radio : vehicle.getListOfRadios())
+            if (radio.getRadioCharacteristics().isOthCapable())
+               maxRange = Math.max(maxRange, radio.getLosRange());
+
+         // convert the range to kiloyards
+         range = String.valueOf((maxRange * ConstantValues.NAUTICAL_MILE_IN_YDS) / 1000);
+      }
+      catch (Exception e)
+      {
+         LoggingManager.getSystemErrorLogger().error("Exception while getting OTH range: ", e);
+      }
+
+      return range;
+   }
+
+
+   /**
+    * To get vehicle altitude depth.
+    * 
+    * @return the altitude depth.
+    */
+   public String getVehicleAltitudeDepth()
+   {
+      return String.valueOf(VehicleState.model.node.getDepth());
+   }
+
+
+   /**
+    * To set vehicle altitude depth.
+    */
+   public void setVehicleAltitudeDepth(String depth)
+   {
+      VehicleState.handler.setAltitudeDepth(Double.parseDouble(depth));
+
+   }
+
+
+   /**
+    * To get vehicle GPS latitude.
+    * 
+    * @return the GPS latitude.
+    */
+   public String getVehicleGPSLatitude()
+   {
+      return String.valueOf(VehicleState.model.node.getLatitude());
+   }
+
+
+   /**
+    * To set vehicle GPS latitude.
+    * 
+    * @param latitude the GPS latitude.
+    */
+   public void setVehicleGPSLatitude(String latitude)
+   {
+      VehicleState.handler.setGpsLatitude(Double.parseDouble(latitude));
+
+   }
+
+
+   /**
+    * To get vehicle GPS longitude.
+    * 
+    * @return the GPS longitude.
+    */
+   public String getVehicleGPSLongitude()
+   {
+      return String.valueOf(VehicleState.model.node.getLongitude());
+   }
+
+
+   /**
+    * To set vehicle GPS longitude.
+    * 
+    * TODO: Move code to handler
+    * 
+    * @param longitude the GPS longitude.
+    */
+   public void setVehicleGPSLongitude(String longitude)
+   {
+      VehicleState.handler.setGpsLongitude(Double.parseDouble(longitude));
+
+   }
+
+
+   /**
+    * Get the current system status
+    * 
+    * @return GO if system is up, NO_GO otherwise
+    */
+   public String getMvcsSystemStatus()
+   {
+      Status s = VehicleState.model.node.getHardwareStatus();
+
+      if (s == Status.GOOD)
+         return ConstantValues.HARDWARE_STATUS_GO;
+      else
+         return ConstantValues.HARDWARE_STATUS_NO_GO;
+   }
+
+
+   /**
+    * Sets RF switch input and output mode. Values are "RADIO,RF_OUTPUT". Values for RADIO are "LOS"
+    * and "OTH". Values for RFOUTPUT are RFOutputType such as "LNR", "MAIN", "MBAY", "TEST",
+    * "TEST_MAIN", and "TEST_LNR".
+    * 
+    * @param radioRfoutput - the value to change RF switch.
+    */
+   public void setVehicleRequestMatrixSwitchMode(String radioRfoutput)
+   {
+      try
+      {
+         logger.debug("External request to set RF switch [Mode:{}]", radioRfoutput);
+
+         // IR-2017-0176 Block external commands during LOCR
+         if (VcaLinkManager.getInstance().getVcaNodeBean().isInAutoLocRecovery())
+         {
+            // Not allow antenna change. Let the LOCR do the work.
+            logger.info("External command is blocked because the LOC-recovery is in progress.");
+            return;
+         }
+
+         String[] params = radioRfoutput.split(",");
+         if (params.length != 2)
+         {
+            LoggingManager.getPrimaryLogger().error("Invalid value {} to change RF switch.", radioRfoutput);
+            return;
+         }
+
+         CommsType commsType = CommsType.valueOf(params[0].trim());
+         RFOutputType rfOutputType = RFOutputType.valueOf(params[1].trim());
+
+         LinkModel link = VehicleState.model.node.getFirstLinkByCommsType(commsType);
+         VehicleState.handler.requestRf(link.getLinkId(), rfOutputType, true);
+      }
+      catch (Exception e)
+      {
+         LoggingManager.getPrimaryLogger().error("Error change matrix switch mode: ", e);
+      }
+   }
+
+
+   /**
+    * To get the vehicle zeroized status.
+    * 
+    * @return "TRUE" if keyed otherwise returns "FALSE".
+    */
+   public String getVehicleZeroized()
+   {
+      return VehicleState.model.node.isKeyed() ? "FALSE" : "TRUE";
+   }
+
+
+   /**
+    * To set the vehicle zeroized status.
+    * 
+    * @param zeroize - "TRUE" to set zeroized otherwise ignored.
+    */
+   public void setVehicleZeroized(String zeroize)
+   {
+      if (Boolean.parseBoolean(zeroize))
+         VehicleState.handler.requestZeroize();
+   }
+
+}// end of class
