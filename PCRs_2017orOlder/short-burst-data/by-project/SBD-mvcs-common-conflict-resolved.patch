Index: build/build-global.xml
===================================================================
--- build/build-global.xml	(revision 9620)
+++ build/build-global.xml	(working copy)
@@ -49,6 +49,7 @@
 	<property name="main.class.plugin.scu" value="mil.navy.lcs.mvcs.plugins.scu.ScuPlugin" />
 	<property name="main.class.plugin.rt1944" value="mil.navy.lcs.mvcs.plugins.rt1944.gui.Rt1944ThickClient" />
 	<property name="main.class.plugin.prc117" value="mil.navy.mvcs.plugins.prc117f.Prc117Main" />
+	<property name="main.class.plugin.mcg101" value="mil.navy.mvcs.plugins.mcg101.MCG101Plugin" />
 	<property name="main.class.rim.scu" value="mil.navy.sscsd.mvcs.rim.iridium.snmp.Agent" />
 	<property name="main.class.rim.prc117" value="mil.navy.mvcs.rim.prc117f.Prc117Main" />
 	<property name="main.class.mission.builder" value="mil.navy.lcs.mvcs.mission.server.AppletServer" />
Index: build/build.xml
===================================================================
--- build/build.xml	(revision 9620)
+++ build/build.xml	(working copy)
@@ -12,6 +12,8 @@
 
 	<property name="plugin.scu.name" value="mvcs-plugin-scu" />
 	<property name="plugin.scu.dir.name" value="scu" />
+	<property name="plugin.mcg101.name" value="mvcs-plugin-mcg101" />
+	<property name="plugin.mcg101.dir.name" value="mcg101" />
 	<property name="plugin.rt1944.name" value="mvcs-plugin-rt1944" />
 	<property name="plugin.rt1944.dir.name" value="rt1944" />
 	<property name="plugin.prc117.name" value="mvcs-plugin-prc117" />
@@ -40,7 +42,7 @@
 
 	<import file="${scripts.dir}/build-global.xml" />
 
-	<property name="mvcs.classpath.addition" value="../plugins/${plugin.scu.dir.name}/bin/${plugin.scu.dir.name}.jar ../plugins/${plugin.rt1944.dir.name}/bin/${plugin.rt1944.dir.name}.jar ../plugins/${plugin.ips250.dir.name}/bin/${plugin.ips250.dir.name}.jar ../plugins/${plugin.prc117.dir.name}/bin/${plugin.prc117.dir.name}.jar ../plugins/${plugin.kg175.dir.name}/bin/${plugin.kg175.dir.name}.jar ../rims/${rim.scu.dir.name}/bin/${rim.scu.dir.name}.jar ../rims/${rim.prc117.dir.name}/bin/${rim.prc117.dir.name}.jar" />
+	<property name="mvcs.classpath.addition" value="../plugins/${plugin.mcg101.dir.name}/bin/${plugin.mcg101.dir.name}.jar ../plugins/${plugin.scu.dir.name}/bin/${plugin.scu.dir.name}.jar ../plugins/${plugin.rt1944.dir.name}/bin/${plugin.rt1944.dir.name}.jar ../plugins/${plugin.ips250.dir.name}/bin/${plugin.ips250.dir.name}.jar ../plugins/${plugin.prc117.dir.name}/bin/${plugin.prc117.dir.name}.jar ../plugins/${plugin.kg175.dir.name}/bin/${plugin.kg175.dir.name}.jar ../rims/${rim.scu.dir.name}/bin/${rim.scu.dir.name}.jar ../rims/${rim.prc117.dir.name}/bin/${rim.prc117.dir.name}.jar" />
 	<!-- ../tools/${mission.builder.dir.name}/bin/${mission.builder.dir.name}.jar" />-->
 
 	<target name="remove.build.classes">
@@ -325,6 +327,8 @@
 			<param name="vessel" value="${sca.vessel}" />
 		</antcall>
 
+		<antcall target="compile.and.build.mcg101.plugin" />
+
 		<antcall target="compile.and.build.rt1944.plugin" />
 
 		<antcall target="compile.and.build.prc117.plugin" />
@@ -357,6 +361,8 @@
 			<param name="vessel" value="${vca.vessel}" />
 		</antcall>
 
+		<antcall target="compile.and.build.mcg101.plugin" />
+		
 		<antcall target="compile.and.build.rt1944.plugin" />
 
 		<antcall target="compile.and.build.prc117.plugin" />
@@ -509,6 +515,21 @@
 			</tarfileset>
 			<!-- Iridium SCU - ABOVE ======================== -->
 
+			<!-- MCG-101 - BELOW ======================== -->
+			<tarfileset dir="${build.dir}/plugins/${plugin.mcg101.dir.name}" prefix="/opt/mvcs" mode="770" group="mvcsexpertusers">
+				<include name="*.sh" />
+			</tarfileset>
+			<tarfileset dir="${build.dir}/plugins/${plugin.mcg101.dir.name}/bin" prefix="${app.path}/plugins/${plugin.mcg101.dir.name}/bin">
+				<include name="*" />
+			</tarfileset>
+			<tarfileset dir="${build.dir}/plugins/${plugin.mcg101.dir.name}/configs" prefix="${app.path}/plugins/${plugin.mcg101.dir.name}/configs" mode="660" group="mvcsexpertusers">
+				<include name="**" />
+			</tarfileset>
+			<tarfileset dir="${build.dir}/plugins/${plugin.mcg101.dir.name}" prefix="${app.path}/plugins/${plugin.mcg101.dir.name}">
+				<include name="storedConfigs" />
+			</tarfileset>
+			<!-- MCG-101 - ABOVE ======================== -->
+
 			<!-- PRC-117 - BELOW ======================== -->
 			<tarfileset dir="${build.dir}/plugins/${plugin.prc117.dir.name}/bin" prefix="${app.path}/plugins/${plugin.prc117.dir.name}/bin">
 				<include name="*" />
@@ -803,6 +824,34 @@
 		</copy>
 	</target>
 
+
+	<target name="compile.and.build.mcg101.plugin">
+		<property name="mcg101.build.path" value="${build.dir}/plugins/${plugin.mcg101.dir.name}" />
+		<!-- Create necessary directories for the MCG101 Plugin project -->
+		<mkdir dir="${mcg101.build.path}/classes" />
+		<mkdir dir="${mcg101.build.path}/bin" />
+		<mkdir dir="${mcg101.build.path}/storedConfigs" />
+
+		<!-- Compile MCG101 Plugin project -->
+		<antcall target="build.project">
+			<param name="project.name" value="${plugin.mcg101.name}" />
+			<param name="compile.dest.dir" value="${mcg101.build.path}/classes" />
+		</antcall>
+
+		<!-- Build MCG101 Plugin JAR -->
+		<antcall target="jar">
+			<param name="jar.app.name" value="${plugin.mcg101.name}" />
+			<param name="jar.main.class" value="${main.class.plugin.mcg101}" />
+			<param name="jar.build.dir" value="${mcg101.build.path}/classes" />
+			<param name="jar.manifest.classpath" value="${plugins.manifest.classpath}" />
+			<param name="jar.path" value="${mcg101.build.path}/bin/${plugin.mcg101.dir.name}.jar" />
+		</antcall>
+		<copy todir="${mcg101.build.path}/configs">
+			<fileset dir="${plugin.mcg101.name}/configs" includes="**" />
+		</copy>
+	</target>
+	
+
 	<target name="compile.and.build.rt1944.plugin">
 		<property name="rt1944.build.path" value="${build.dir}/plugins/${plugin.rt1944.dir.name}" />
 		<!-- Create necessary directories for the RT-1944 Plugin project -->
@@ -1132,6 +1181,11 @@
 			<param name="project.name" value="${plugin.scu.name}" />
 		</antcall>
 
+		<!-- Compile MCG101 Plugin project -->
+		<antcall target="build.project">
+			<param name="project.name" value="${plugin.mcg101.name}" />
+		</antcall>
+
 		<!-- Compile the PRC-117 Plugin and GUI projects w/ circular dependencies -->
 		<antcall target="build.project">
 			<param name="project.name" value="${plugin.prc117.name}" />
@@ -1190,6 +1244,9 @@
 			<fileset dir="${plugin.scu.name}/${source.dir}">
 				<include name="${file.pattern}" />
 			</fileset>
+			<fileset dir="${plugin.mcg101.name}/${source.dir}">
+				<include name="${file.pattern}" />
+			</fileset>
 			<fileset dir="${plugin.ips250.name}/${source.dir}">
 				<include name="${file.pattern}" />
 			</fileset>
Index: src/main/java/mil/navy/lcs/mvcs/common/config/ConfigManager.java
===================================================================
--- src/main/java/mil/navy/lcs/mvcs/common/config/ConfigManager.java	(revision 9620)
+++ src/main/java/mil/navy/lcs/mvcs/common/config/ConfigManager.java	(working copy)
@@ -958,7 +958,7 @@
       CredentialSimple credential = null;
       for (CredentialSimple c : listOfCredentials)
       {
-         if (c.getId().equals(id))
+         if (c.getId().equalsIgnoreCase(id))
          {
             credential = c;
             break;
Index: src/main/java/mil/navy/lcs/mvcs/common/config/model/Radio.java
===================================================================
--- src/main/java/mil/navy/lcs/mvcs/common/config/model/Radio.java	(revision 9620)
+++ src/main/java/mil/navy/lcs/mvcs/common/config/model/Radio.java	(working copy)
@@ -10,10 +10,8 @@
 import mil.navy.lcs.mvcs.common.constants.RadioConstants;
 
 /**
- * Radio
+ * This class represents a radio of the mission configuration.
  *
- * TODO {Purpose of This Class}
- *
  * Id: $Id$ $LastChangedBy: $ $LastChangedDate: $ $LastChangedRevision: $
  *
  */
@@ -23,6 +21,7 @@
    static final long serialVersionUID = 221L;
 
    private String encrypterTypeId;
+   private String encrypterRedIp;
    private String ampId;
    private String secondaryAmpId;
    private String telephoneNum;
@@ -509,4 +508,22 @@
    {
       this.antennaCoverages = antennaCoverages;
    }
+
+
+   /**
+    * @return the encrypterRedIp (the red side IP)
+    */
+   public String getEncrypterRedIp()
+   {
+      return this.encrypterRedIp;
+   }
+
+
+   /**
+    * @param encrypterRedIp the encrypterRedIp to set
+    */
+   public void setEncrypterRedIp(String encrypterRedIp)
+   {
+      this.encrypterRedIp = encrypterRedIp;
+   }
 }
Index: src/main/java/mil/navy/lcs/mvcs/common/constants/HardwareConstants.java
===================================================================
--- src/main/java/mil/navy/lcs/mvcs/common/constants/HardwareConstants.java	(revision 9620)
+++ src/main/java/mil/navy/lcs/mvcs/common/constants/HardwareConstants.java	(working copy)
@@ -11,16 +11,14 @@
 import mil.navy.lcs.mvcs.common.utils.FileUtils;
 
 /**
- * HardwareConstants
+ * This class contains hardware constants. Constant values are loaded during runtime from the
+ * hardware-constants.properties file from the mil.navy.lcs.mvcs.common.constants in the resources
+ * folder.
  *
- * TODO {Purpose of This Class}
- *
  * Id: $Id$ $LastChangedBy: $ $LastChangedDate: $ $LastChangedRevision: $
- *
  */
 public class HardwareConstants
 {
-   private static final HardwareConstants INSTANCE = new HardwareConstants();
    private static Properties CONSTANTS = getConstants();
 
 
Index: src/main/java/mil/navy/lcs/mvcs/common/constants/HardwareConstantsEnum.java
===================================================================
--- src/main/java/mil/navy/lcs/mvcs/common/constants/HardwareConstantsEnum.java	(revision 9620)
+++ src/main/java/mil/navy/lcs/mvcs/common/constants/HardwareConstantsEnum.java	(working copy)
@@ -4,14 +4,61 @@
 
 
 /**
- * ApplicationConstantsEnum
+ * Hardware constants enumeration key. The keys must match with property key of the hardware
+ * constant file from the hardware-constants.properties file from the
+ * mil.navy.lcs.mvcs.common.constants in the resources folder.
  *
- * TODO {Purpose of This Class}
- *
  * Id: $Id$ $LastChangedBy: $ $LastChangedDate: $ $LastChangedRevision: $
  *
  */
 public enum HardwareConstantsEnum {
 
-   MISSION, SHIP, VEHICLE, SPS, SHS, ROUTER, MS, PSU, UPS, LANBYPASS, RADIO, VRC99RMS, VRC99_AMPLIFIER, RT1944, RT1944_AMPLIFIER, PRC117, PRC117_AMPLIFIER, RT1988, IRIDIUM, HFGW, KIV7, LCS1, LCS2, LCS3, USV, ASW, RMV, MTV, UUV, SBAND, LBAND, CB, DUMMY_LOAD, MAIN_ANTENNA, LNR_ANTENNA, LNR_AMPLIFIER, RF_TEST_PORT, MEDIA_CONVERTER, LOS_MAIN_ANTENNA, LOS_LNR_ANTENNA, LOS_RF_TEST_PORT, OTH_MAIN_ANTENNA, OTH_LNR_ANTENNA, OTH_RF_TEST_PORT, LOS_RADIO_AMP, OTH_RADIO_AMP, IPS250
+   MISSION, // this comment is added to keep the format of source
+   SHIP, //
+   VEHICLE, //
+   SPS, //
+   SHS, //
+   ROUTER, //
+   MS, //
+   PSU, //
+   UPS, //
+   LANBYPASS, //
+   RADIO, //
+   VRC99RMS, //
+   VRC99_AMPLIFIER, //
+   RT1944, //
+   RT1944_AMPLIFIER, //
+   PRC117, //
+   PRC117_AMPLIFIER, //
+   RT1988, //
+   IRIDIUM, //
+   HFGW, //
+   MCG101, //
+   KIV7, //
+   LCS1, //
+   LCS2, //
+   LCS3, //
+   USV, //
+   ASW, //
+   RMV, //
+   MTV, //
+   UUV, //
+   SBAND, //
+   LBAND, //
+   CB, //
+   DUMMY_LOAD, //
+   MAIN_ANTENNA, //
+   LNR_ANTENNA, //
+   LNR_AMPLIFIER, //
+   RF_TEST_PORT, //
+   MEDIA_CONVERTER, //
+   LOS_MAIN_ANTENNA, //
+   LOS_LNR_ANTENNA, //
+   LOS_RF_TEST_PORT, //
+   OTH_MAIN_ANTENNA, //
+   OTH_LNR_ANTENNA, //
+   OTH_RF_TEST_PORT, //
+   LOS_RADIO_AMP, //
+   OTH_RADIO_AMP, //
+   IPS250
 }
\ No newline at end of file
Index: src/main/java/mil/navy/lcs/mvcs/common/constants/HelpConstants.java
===================================================================
--- src/main/java/mil/navy/lcs/mvcs/common/constants/HelpConstants.java	(revision 9620)
+++ src/main/java/mil/navy/lcs/mvcs/common/constants/HelpConstants.java	(working copy)
@@ -20,7 +20,6 @@
  */
 public class HelpConstants
 {
-   private static final HelpConstants INSTANCE = new HelpConstants();
    private static Properties CONSTANTS = getConstants();
 
 
Index: src/main/java/mil/navy/lcs/mvcs/common/constants/RadioConstants.java
===================================================================
--- src/main/java/mil/navy/lcs/mvcs/common/constants/RadioConstants.java	(revision 9620)
+++ src/main/java/mil/navy/lcs/mvcs/common/constants/RadioConstants.java	(working copy)
@@ -15,9 +15,9 @@
 import mil.navy.lcs.mvcs.common.utils.XmlUtils;
 
 /**
- * RadioConstants
+ * This class contains radio constant values such as characteristics of radio and associated
+ * encryption device.
  *
- * TODO {Purpose of This Class}
  *
  * Id: $Id$ $LastChangedBy: $ $LastChangedDate: $ $LastChangedRevision: $
  *
@@ -26,14 +26,11 @@
 {
    private static final long serialVersionUID = 230L;
 
-   private static final RadioConstants INSTANCE = new RadioConstants();
    private static List<RadioCharacteristics> listOfRadioCharacteristics = getListOfRadioCharacteristics();
    private static List<Encrypter> listOfEncrypters = getListOfEncrypters();
 
 
-   /**
-    *
-    */
+   /** The default constructor */
    private RadioConstants()
    {
    }
@@ -72,7 +69,7 @@
       Encrypter encrypter = null;
       for (Encrypter rc : listOfEncrypters)
       {
-         if (typeId.equals(rc.getTypeId()))
+         if (typeId.equalsIgnoreCase(rc.getTypeId()))
          {
             encrypter = rc;
          }
Index: src/main/java/mil/navy/lcs/mvcs/common/encryptor/EncryptorPluginManager.java
===================================================================
--- src/main/java/mil/navy/lcs/mvcs/common/encryptor/EncryptorPluginManager.java	(revision 9620)
+++ src/main/java/mil/navy/lcs/mvcs/common/encryptor/EncryptorPluginManager.java	(working copy)
@@ -3,17 +3,17 @@
 package mil.navy.lcs.mvcs.common.encryptor;
 
 
-import java.util.Enumeration;
+import java.util.Collection;
 import java.util.Hashtable;
 
-import mil.navy.lcs.mvcs.common.config.ConfigManager;
-import mil.navy.lcs.mvcs.common.config.exception.ConfigException;
 import mil.navy.lcs.mvcs.common.encryptor.interfaces.IEncryptorPlugin;
 import mil.navy.lcs.mvcs.common.log.LoggingManager;
+import mil.navy.lcs.mvcs.iface.encryption.IPS250EncryptionDevice;
+import mil.navy.lcs.mvcs.iface.model.node.RadioLink;
 
 
 /**
- * This class represents the base plugin manager for all of the encryptor plugins. There are
+ * This class represents the base plug-in manager for all of the encryptor plug-ins. There are
  * versions for both the SCA and VCA.
  * <p>
  * Date Created: April 6th, 2011
@@ -25,11 +25,11 @@
  */
 public abstract class EncryptorPluginManager
 {
-   /** Hashtable used to hold the name of plugin class. Key is plugin name. */
-   protected Hashtable<String, String> encryptorPluginClassHashTable;
+   /** To hold the class name of plug-in class. Key is plug-in type. */
+   protected Hashtable<String, String> encryptorPluginClassNames;
 
-   /** Hashtable to hold the plugins. Key is plugin name. */
-   protected Hashtable<String, IEncryptorPlugin> encryptorPluginsHashTable;
+   /** To hold the plug-ins. Key is the red side IP of the encryption device. */
+   protected Hashtable<String, IEncryptorPlugin> runtimeEncryptorPlugins;
 
 
    /**
@@ -37,114 +37,64 @@
     */
    public EncryptorPluginManager()
    {
-      // Initialize the hashtables for the plugins
-      encryptorPluginsHashTable = new Hashtable<String, IEncryptorPlugin>();
-      encryptorPluginClassHashTable = new Hashtable<String, String>();
+      // Initialize the hash-tables
+      runtimeEncryptorPlugins = new Hashtable<String, IEncryptorPlugin>();
+      encryptorPluginClassNames = new Hashtable<String, String>();
    }
 
 
    /**
-    * Method used to get the key status of the encryptor.
-    * 
-    * @param encryptorPluginName The name of the encryptor plugin.
-    * @return boolean The result of whether the encryptor is keyed.
+    * To initialize all of plug-ins and store them in a map with unique key such as red side IP. To
+    * invoke start method of each plug-in.
     */
-   public boolean getEncryptorKeyStatusByPluginName(String encryptorPluginName)
+   protected void instantiatePlugins(Collection<RadioLink> radios)
    {
-      //
-      boolean result = false;
-
-      try
+      for (RadioLink radio : radios)
       {
-         result = encryptorPluginsHashTable.get(encryptorPluginName).isKeyed();
-      }
-      catch (NullPointerException n)
-      {
-         System.out.print("Plugin was not found in hashtable!\n");
-      }
-      return result;
-   }
+         try
+         {
+            IPS250EncryptionDevice encryptionDevice = radio.getEncryptionDevice();
 
+            // Ensure the encryptor type is valid
+            if (encryptionDevice == null || encryptionDevice.getTypeId() == null)
+               continue;
 
-   /**
-    * Method which is used to get the interface to an Encryptor plugin.
-    * 
-    * @param encryptorPluginName The name of the encryptor plugin.
-    * @return IEncryptorPlugin The encryptor plugin.
-    */
-   public IEncryptorPlugin getEncryptorPluginByName(String encryptorPluginName)
-   {
-      // Interface variable for the plugin.
-      IEncryptorPlugin plugin = null;
+            // Take the IP (red side) and get the name of the plug-in class
+            String redIp = encryptionDevice.getRedIpAddress();
 
-      plugin = (IEncryptorPlugin) encryptorPluginsHashTable.get(encryptorPluginName);
+            // Ensure the plug-in is not already initialized with the same IP (red side)
+            if (redIp == null || runtimeEncryptorPlugins.containsKey(redIp))
+            {
+               LoggingManager.getPrimaryLogger().info("Encryptor " + encryptionDevice.getTypeId() + " plug-in already exists with the same IP " + redIp);
+               continue;
+            }
 
-      return plugin;
-   }
+            // Find the plug-in class name
+            String encryptorPlugin = encryptorPluginClassNames.get(encryptionDevice.getTypeId());
 
+            // Ensure the plug-in class name is valid
+            if (encryptorPlugin == null)
+            {
+               LoggingManager.getPrimaryLogger().info("Encryptor plug-in not found for " + encryptionDevice.getTypeId());
+               continue;
+            }
 
-   /**
-    * Method which is used to return the name of the class of an encryptor plugin.
-    * 
-    * @param encryptorPluginName The name of the plugin to search for.
-    * @return String The name of the encryptor plugin class.
-    */
-   public String getEncryptorPluginClass(String encryptorPluginName)
-   {
-      return ((String) encryptorPluginClassHashTable.get(encryptorPluginName));
-   }
+            // Get the qualifying class name of the plug-in.
+            Class<?> newRadioClass = Class.forName(encryptorPlugin);
 
-
-   /**
-    * Method which is used to find out what type of encryptor it is.
-    * 
-    * @param encryptorName The name of the encryptor.
-    * @return String The type of the encryptor.
-    * @throws ConfigException
-    */
-   public String getEncryptorType(String encryptorName) throws ConfigException
-   {
-      return ConfigManager.getInstance().getEncryptorTypeByName(encryptorName);
-   }
-
-
-   /**
-    * Method which is used for initializing and starting the encryptor plugins.
-    */
-   public void instantiatePlugins()
-   {
-      Enumeration<String> enumeration = encryptorPluginClassHashTable.keys();
-      String encryptorPluginName = "";
-
-      while (enumeration.hasMoreElements())
-      {
-         try
-         {
-            // Take the name of a radio and get the name of the plugin class
-            encryptorPluginName = enumeration.nextElement();
-
-            // Get the class name of the plugin.
-            Class<?> newRadioClass = Class.forName((String) encryptorPluginClassHashTable.get(encryptorPluginName));
-
             // Use Reflection to instantiate the class
             final IEncryptorPlugin pluginInstance = (IEncryptorPlugin) newRadioClass.newInstance();
+            LoggingManager.getPrimaryLogger().info("Instantiated a plug-in with " + newRadioClass.getName());
 
-            // TODO Will need to set according to config file.........?
-            // pluginInstance.setIPAddress("192.168.2.1");
+            // start the plug-in with valid red side IP.
+            pluginInstance.startPlugin(redIp);
+            LoggingManager.getPrimaryLogger().info("Started encryptor plug-in: " + encryptorPlugin + " with red side IP:" + redIp);
 
-            LoggingManager.getPrimaryLogger().info("Instantiated: " + encryptorPluginName);
-
-            // start the plugin.
-            pluginInstance.startPlugin();
-
-            LoggingManager.getPrimaryLogger().info("Started encryptor plugin: " + encryptorPluginName);
-
-            // Put the plugin object in the pluginsHashTable hashtable
-            encryptorPluginsHashTable.put(encryptorPluginName, pluginInstance);
+            // Put the plug-in object in the pluginsHashTable hash-table
+            runtimeEncryptorPlugins.put(redIp, pluginInstance);
          }
          catch (Exception ex)
          {
-            // Log the exception.
             LoggingManager.getPrimaryLogger().error("Exception in instantiatePlugins(): ", ex);
          }
       }
@@ -152,55 +102,27 @@
 
 
    /**
-    * Method which is used to sanitize all encryptors.
+    * To zeroize all encryptors.
     */
-   public abstract void sanitizeAllEncryptors();
-
-
-   /**
-    * Method which is used to wipe all encryptors.
-    */
-   public abstract void wipeAllEncryptors();
-
-
-   /**
-    * Method which is used to zeroize all encryptors.
-    */
    public abstract void zeroizeAllEncryptors();
 
 
    /**
-    * Method which is used to add the encryptor plugin name and class to the hashtable.
+    * To get the encryptor plug-in for the given radio object
     * 
-    * @param ePluginName The name of the plugin.
-    * @param ePluginClass The class of the plugin.
-    * @return
+    * @param radio - The radio object
+    * @return the encryptor plug-in
     */
-   protected boolean addEncryptorPluginNameAndClass(String encryptorPluginName, String encryptorPluginClass)
+   public IEncryptorPlugin getEncryptorPlugin(RadioLink radio)
    {
-      // The result of adding the plugin to the hashtable.
-      boolean result = true;
-
-      try
+      if (radio.getEncryptionDevice() != null)
       {
-         encryptorPluginClassHashTable.put(encryptorPluginName, encryptorPluginClass);
+         String redIp = radio.getEncryptionDevice().getRedIpAddress();
+         return runtimeEncryptorPlugins.get(redIp);
       }
-      catch (Exception ex)
-      {
-         // Log the exception.
-         LoggingManager.getPrimaryLogger().error("Error: ", ex);
-         result = false;
-      }
 
-      return result;
+      return null;
    }
+   
 
-
-   /**
-    * Method Description Needed.
-    */
-   protected void shutdown()
-   {
-      // TODO Plugin shutdown logic.
-   }
 }
\ No newline at end of file
Index: src/main/java/mil/navy/lcs/mvcs/common/encryptor/EncryptorPluginManager.java.mine
===================================================================
--- src/main/java/mil/navy/lcs/mvcs/common/encryptor/EncryptorPluginManager.java.mine	(revision 0)
+++ src/main/java/mil/navy/lcs/mvcs/common/encryptor/EncryptorPluginManager.java.mine	(working copy)
@@ -0,0 +1,128 @@
+
+
+package mil.navy.lcs.mvcs.common.encryptor;
+
+
+import java.util.Collection;
+import java.util.Hashtable;
+
+import mil.navy.lcs.mvcs.common.encryptor.interfaces.IEncryptorPlugin;
+import mil.navy.lcs.mvcs.common.log.LoggingManager;
+import mil.navy.lcs.mvcs.iface.encryption.IPS250EncryptionDevice;
+import mil.navy.lcs.mvcs.iface.model.node.RadioLink;
+
+
+/**
+ * This class represents the base plug-in manager for all of the encryptor plug-ins. There are
+ * versions for both the SCA and VCA.
+ * <p>
+ * Date Created: April 6th, 2011
+ * <p>
+ * $LastChangedBy$ $LastChangedDate$ $LastChangedRevision$
+ * 
+ * @author jnelson
+ * @version 1.0
+ */
+public abstract class EncryptorPluginManager
+{
+   /** To hold the class name of plug-in class. Key is plug-in type. */
+   protected Hashtable<String, String> encryptorPluginClassNames;
+
+   /** To hold the plug-ins. Key is the red side IP of the encryption device. */
+   protected Hashtable<String, IEncryptorPlugin> runtimeEncryptorPlugins;
+
+
+   /**
+    * Default Constructor
+    */
+   public EncryptorPluginManager()
+   {
+      // Initialize the hash-tables
+      runtimeEncryptorPlugins = new Hashtable<String, IEncryptorPlugin>();
+      encryptorPluginClassNames = new Hashtable<String, String>();
+   }
+
+
+   /**
+    * To initialize all of plug-ins and store them in a map with unique key such as red side IP. To
+    * invoke start method of each plug-in.
+    */
+   protected void instantiatePlugins(Collection<RadioLink> radios)
+   {
+      for (RadioLink radio : radios)
+      {
+         try
+         {
+            IPS250EncryptionDevice encryptionDevice = radio.getEncryptionDevice();
+
+            // Ensure the encryptor type is valid
+            if (encryptionDevice == null || encryptionDevice.getTypeId() == null)
+               continue;
+
+            // Take the IP (red side) and get the name of the plug-in class
+            String redIp = encryptionDevice.getRedIpAddress();
+
+            // Ensure the plug-in is not already initialized with the same IP (red side)
+            if (redIp == null || runtimeEncryptorPlugins.containsKey(redIp))
+            {
+               LoggingManager.getPrimaryLogger().info("Encryptor " + encryptionDevice.getTypeId() + " plug-in already exists with the same IP " + redIp);
+               continue;
+            }
+
+            // Find the plug-in class name
+            String encryptorPlugin = encryptorPluginClassNames.get(encryptionDevice.getTypeId());
+
+            // Ensure the plug-in class name is valid
+            if (encryptorPlugin == null)
+            {
+               LoggingManager.getPrimaryLogger().info("Encryptor plug-in not found for " + encryptionDevice.getTypeId());
+               continue;
+            }
+
+            // Get the qualifying class name of the plug-in.
+            Class<?> newRadioClass = Class.forName(encryptorPlugin);
+
+            // Use Reflection to instantiate the class
+            final IEncryptorPlugin pluginInstance = (IEncryptorPlugin) newRadioClass.newInstance();
+            LoggingManager.getPrimaryLogger().info("Instantiated a plug-in with " + newRadioClass.getName());
+
+            // start the plug-in with valid red side IP.
+            pluginInstance.startPlugin(redIp);
+            LoggingManager.getPrimaryLogger().info("Started encryptor plug-in: " + encryptorPlugin + " with red side IP:" + redIp);
+
+            // Put the plug-in object in the pluginsHashTable hash-table
+            runtimeEncryptorPlugins.put(redIp, pluginInstance);
+         }
+         catch (Exception ex)
+         {
+            LoggingManager.getPrimaryLogger().error("Exception in instantiatePlugins(): ", ex);
+         }
+      }
+   }
+
+
+   /**
+    * To zeroize all encryptors.
+    */
+   public abstract void zeroizeAllEncryptors();
+
+
+   /**
+    * To get the encryptor plug-in for the given radio object
+    * 
+    * @param radio - The radio object
+    * @return the encryptor plug-in
+    */
+   public IEncryptorPlugin getEncryptorPlugin(RadioLink radio)
+   {
+      if (radio.getEncryptionDevice() != null)
+      {
+         String redIp = radio.getEncryptionDevice().getRedIpAddress();
+         return runtimeEncryptorPlugins.get(redIp);
+      }
+
+      return null;
+   }
+   
+
+}
\ No newline at end of file
Index: src/main/java/mil/navy/lcs/mvcs/common/encryptor/EncryptorPluginManager.java.r9603
===================================================================
--- src/main/java/mil/navy/lcs/mvcs/common/encryptor/EncryptorPluginManager.java.r9603	(revision 0)
+++ src/main/java/mil/navy/lcs/mvcs/common/encryptor/EncryptorPluginManager.java.r9603	(working copy)
@@ -0,0 +1,205 @@
+
+
+package mil.navy.lcs.mvcs.common.encryptor;
+
+
+import java.util.Enumeration;
+import java.util.Hashtable;
+
+import mil.navy.lcs.mvcs.common.config.ConfigManager;
+import mil.navy.lcs.mvcs.common.config.exception.ConfigException;
+import mil.navy.lcs.mvcs.common.encryptor.interfaces.IEncryptorPlugin;
+import mil.navy.lcs.mvcs.common.log.LoggingManager;
+
+
+/**
+ * This class represents the base plugin manager for all of the encryptor plugins. There are versions for both the SCA and VCA.
+ * <p>
+ * Date Created: April 6th, 2011
+ * <p>
+ * $LastChangedBy$ $LastChangedDate$ $LastChangedRevision$
+ * 
+ * @author jnelson
+ * @version 1.0
+ */
+public abstract class EncryptorPluginManager
+{
+   /** Hashtable used to hold the name of plugin class. Key is plugin name. */
+   protected Hashtable<String, String> encryptorPluginClassHashTable;
+
+   /** Hashtable to hold the plugins. Key is plugin name. */
+   protected Hashtable<String, IEncryptorPlugin> encryptorPluginsHashTable;
+
+
+   /**
+    * Default Constructor
+    */
+   public EncryptorPluginManager()
+   {
+      // Initialize the hashtables for the plugins
+      encryptorPluginsHashTable = new Hashtable<String, IEncryptorPlugin>();
+      encryptorPluginClassHashTable = new Hashtable<String, String>();
+   }
+
+
+   /**
+    * Method used to get the key status of the encryptor.
+    * 
+    * @param encryptorPluginName The name of the encryptor plugin.
+    * @return boolean The result of whether the encryptor is keyed.
+    */
+   public boolean getEncryptorKeyStatusByPluginName(String encryptorPluginName)
+   {
+      //
+      boolean result = false;
+
+      try
+      {
+         result = encryptorPluginsHashTable.get(encryptorPluginName).isKeyed();
+      }
+      catch (NullPointerException n)
+      {
+         System.out.print("Plugin was not found in hashtable!\n");
+      }
+      return result;
+   }
+
+
+   /**
+    * Method which is used to get the interface to an Encryptor plugin.
+    * 
+    * @param encryptorPluginName The name of the encryptor plugin.
+    * @return IEncryptorPlugin The encryptor plugin.
+    */
+   public IEncryptorPlugin getEncryptorPluginByName(String encryptorPluginName)
+   {
+      // Interface variable for the plugin.
+      IEncryptorPlugin plugin = null;
+
+      plugin = (IEncryptorPlugin) encryptorPluginsHashTable.get(encryptorPluginName);
+
+      return plugin;
+   }
+
+
+   /**
+    * Method which is used to return the name of the class of an encryptor plugin.
+    * 
+    * @param encryptorPluginName The name of the plugin to search for.
+    * @return String The name of the encryptor plugin class.
+    */
+   public String getEncryptorPluginClass(String encryptorPluginName)
+   {
+      return ((String) encryptorPluginClassHashTable.get(encryptorPluginName));
+   }
+
+
+   /**
+    * Method which is used to find out what type of encryptor it is.
+    * 
+    * @param encryptorName The name of the encryptor.
+    * @return String The type of the encryptor.
+    * @throws ConfigException
+    */
+   public String getEncryptorType(String encryptorName) throws ConfigException
+   {
+      return ConfigManager.getInstance().getEncryptorTypeByName(encryptorName);
+   }
+
+
+   /**
+    * Method which is used for initializing and starting the encryptor plugins.
+    */
+   public void instantiatePlugins()
+   {
+      Enumeration<String> enumeration = encryptorPluginClassHashTable.keys();
+      String encryptorPluginName = "";
+
+      while (enumeration.hasMoreElements())
+      {
+         try
+         {
+            // Take the name of a radio and get the name of the plugin class
+            encryptorPluginName = enumeration.nextElement();
+
+            // Get the class name of the plugin.
+            Class<?> newRadioClass = Class.forName((String) encryptorPluginClassHashTable.get(encryptorPluginName));
+
+            // Use Reflection to instantiate the class
+            final IEncryptorPlugin pluginInstance = (IEncryptorPlugin) newRadioClass.newInstance();
+
+            // TODO Will need to set according to config file.........?
+            // pluginInstance.setIPAddress("192.168.2.1");
+
+            LoggingManager.getPrimaryLogger().info("Instantiated: " + encryptorPluginName);
+
+            // start the plugin.
+            pluginInstance.startPlugin();
+
+            LoggingManager.getPrimaryLogger().info("Started encryptor plugin: " + encryptorPluginName);
+
+            // Put the plugin object in the pluginsHashTable hashtable
+            encryptorPluginsHashTable.put(encryptorPluginName, pluginInstance);
+         }
+         catch (Exception ex)
+         {
+            // Log the exception.
+            LoggingManager.getPrimaryLogger().error("Exception in instantiatePlugins(): ", ex);
+         }
+      }
+   }
+
+
+   /**
+    * Method which is used to sanitize all encryptors.
+    */
+   public abstract void sanitizeAllEncryptors();
+
+
+   /**
+    * Method which is used to wipe all encryptors.
+    */
+   public abstract void wipeAllEncryptors();
+
+
+   /**
+    * Method which is used to zeroize all encryptors.
+    */
+   public abstract void zeroizeAllEncryptors();
+
+
+   /**
+    * Method which is used to add the encryptor plugin name and class to the hashtable.
+    * 
+    * @param ePluginName The name of the plugin.
+    * @param ePluginClass The class of the plugin.
+    * @return
+    */
+   protected boolean addEncryptorPluginNameAndClass(String encryptorPluginName, String encryptorPluginClass)
+   {
+      // The result of adding the plugin to the hashtable.
+      boolean result = true;
+
+      try
+      {
+         encryptorPluginClassHashTable.put(encryptorPluginName, encryptorPluginClass);
+      }
+      catch (Exception ex)
+      {
+         // Log the exception.
+         LoggingManager.getPrimaryLogger().error("Error: ", ex);
+         result = false;
+      }
+
+      return result;
+   }
+
+
+   /**
+    * Method Description Needed.
+    */
+   protected void shutdown()
+   {
+      // TODO Plugin shutdown logic.
+   }
+}
\ No newline at end of file
Index: src/main/java/mil/navy/lcs/mvcs/common/encryptor/EncryptorPluginManager.java.r9620
===================================================================
--- src/main/java/mil/navy/lcs/mvcs/common/encryptor/EncryptorPluginManager.java.r9620	(revision 0)
+++ src/main/java/mil/navy/lcs/mvcs/common/encryptor/EncryptorPluginManager.java.r9620	(working copy)
@@ -0,0 +1,206 @@
+
+
+package mil.navy.lcs.mvcs.common.encryptor;
+
+
+import java.util.Enumeration;
+import java.util.Hashtable;
+
+import mil.navy.lcs.mvcs.common.config.ConfigManager;
+import mil.navy.lcs.mvcs.common.config.exception.ConfigException;
+import mil.navy.lcs.mvcs.common.encryptor.interfaces.IEncryptorPlugin;
+import mil.navy.lcs.mvcs.common.log.LoggingManager;
+
+
+/**
+ * This class represents the base plugin manager for all of the encryptor plugins. There are
+ * versions for both the SCA and VCA.
+ * <p>
+ * Date Created: April 6th, 2011
+ * <p>
+ * $LastChangedBy$ $LastChangedDate$ $LastChangedRevision$
+ * 
+ * @author jnelson
+ * @version 1.0
+ */
+public abstract class EncryptorPluginManager
+{
+   /** Hashtable used to hold the name of plugin class. Key is plugin name. */
+   protected Hashtable<String, String> encryptorPluginClassHashTable;
+
+   /** Hashtable to hold the plugins. Key is plugin name. */
+   protected Hashtable<String, IEncryptorPlugin> encryptorPluginsHashTable;
+
+
+   /**
+    * Default Constructor
+    */
+   public EncryptorPluginManager()
+   {
+      // Initialize the hashtables for the plugins
+      encryptorPluginsHashTable = new Hashtable<String, IEncryptorPlugin>();
+      encryptorPluginClassHashTable = new Hashtable<String, String>();
+   }
+
+
+   /**
+    * Method used to get the key status of the encryptor.
+    * 
+    * @param encryptorPluginName The name of the encryptor plugin.
+    * @return boolean The result of whether the encryptor is keyed.
+    */
+   public boolean getEncryptorKeyStatusByPluginName(String encryptorPluginName)
+   {
+      //
+      boolean result = false;
+
+      try
+      {
+         result = encryptorPluginsHashTable.get(encryptorPluginName).isKeyed();
+      }
+      catch (NullPointerException n)
+      {
+         System.out.print("Plugin was not found in hashtable!\n");
+      }
+      return result;
+   }
+
+
+   /**
+    * Method which is used to get the interface to an Encryptor plugin.
+    * 
+    * @param encryptorPluginName The name of the encryptor plugin.
+    * @return IEncryptorPlugin The encryptor plugin.
+    */
+   public IEncryptorPlugin getEncryptorPluginByName(String encryptorPluginName)
+   {
+      // Interface variable for the plugin.
+      IEncryptorPlugin plugin = null;
+
+      plugin = (IEncryptorPlugin) encryptorPluginsHashTable.get(encryptorPluginName);
+
+      return plugin;
+   }
+
+
+   /**
+    * Method which is used to return the name of the class of an encryptor plugin.
+    * 
+    * @param encryptorPluginName The name of the plugin to search for.
+    * @return String The name of the encryptor plugin class.
+    */
+   public String getEncryptorPluginClass(String encryptorPluginName)
+   {
+      return ((String) encryptorPluginClassHashTable.get(encryptorPluginName));
+   }
+
+
+   /**
+    * Method which is used to find out what type of encryptor it is.
+    * 
+    * @param encryptorName The name of the encryptor.
+    * @return String The type of the encryptor.
+    * @throws ConfigException
+    */
+   public String getEncryptorType(String encryptorName) throws ConfigException
+   {
+      return ConfigManager.getInstance().getEncryptorTypeByName(encryptorName);
+   }
+
+
+   /**
+    * Method which is used for initializing and starting the encryptor plugins.
+    */
+   public void instantiatePlugins()
+   {
+      Enumeration<String> enumeration = encryptorPluginClassHashTable.keys();
+      String encryptorPluginName = "";
+
+      while (enumeration.hasMoreElements())
+      {
+         try
+         {
+            // Take the name of a radio and get the name of the plugin class
+            encryptorPluginName = enumeration.nextElement();
+
+            // Get the class name of the plugin.
+            Class<?> newRadioClass = Class.forName((String) encryptorPluginClassHashTable.get(encryptorPluginName));
+
+            // Use Reflection to instantiate the class
+            final IEncryptorPlugin pluginInstance = (IEncryptorPlugin) newRadioClass.newInstance();
+
+            // TODO Will need to set according to config file.........?
+            // pluginInstance.setIPAddress("192.168.2.1");
+
+            LoggingManager.getPrimaryLogger().info("Instantiated: " + encryptorPluginName);
+
+            // start the plugin.
+            pluginInstance.startPlugin();
+
+            LoggingManager.getPrimaryLogger().info("Started encryptor plugin: " + encryptorPluginName);
+
+            // Put the plugin object in the pluginsHashTable hashtable
+            encryptorPluginsHashTable.put(encryptorPluginName, pluginInstance);
+         }
+         catch (Exception ex)
+         {
+            // Log the exception.
+            LoggingManager.getPrimaryLogger().error("Exception in instantiatePlugins(): ", ex);
+         }
+      }
+   }
+
+
+   /**
+    * Method which is used to sanitize all encryptors.
+    */
+   public abstract void sanitizeAllEncryptors();
+
+
+   /**
+    * Method which is used to wipe all encryptors.
+    */
+   public abstract void wipeAllEncryptors();
+
+
+   /**
+    * Method which is used to zeroize all encryptors.
+    */
+   public abstract void zeroizeAllEncryptors();
+
+
+   /**
+    * Method which is used to add the encryptor plugin name and class to the hashtable.
+    * 
+    * @param ePluginName The name of the plugin.
+    * @param ePluginClass The class of the plugin.
+    * @return
+    */
+   protected boolean addEncryptorPluginNameAndClass(String encryptorPluginName, String encryptorPluginClass)
+   {
+      // The result of adding the plugin to the hashtable.
+      boolean result = true;
+
+      try
+      {
+         encryptorPluginClassHashTable.put(encryptorPluginName, encryptorPluginClass);
+      }
+      catch (Exception ex)
+      {
+         // Log the exception.
+         LoggingManager.getPrimaryLogger().error("Error: ", ex);
+         result = false;
+      }
+
+      return result;
+   }
+
+
+   /**
+    * Method Description Needed.
+    */
+   protected void shutdown()
+   {
+      // TODO Plugin shutdown logic.
+   }
+}
\ No newline at end of file
Index: src/main/java/mil/navy/lcs/mvcs/common/encryptor/interfaces/IEncryptorPlugin.java
===================================================================
--- src/main/java/mil/navy/lcs/mvcs/common/encryptor/interfaces/IEncryptorPlugin.java	(revision 9620)
+++ src/main/java/mil/navy/lcs/mvcs/common/encryptor/interfaces/IEncryptorPlugin.java	(working copy)
@@ -16,13 +16,13 @@
 public interface IEncryptorPlugin
 {
    /**
-    * This method is responsible for starting the plugin.
+    * This method is responsible for starting the plug-in.
     */
-   public void startPlugin();
+   public void startPlugin(String ipAddress);
 
 
    /**
-    * This method is responsible for stopping the plugin.
+    * This method is responsible for stopping the plug-in.
     */
    public void stopPlugin();
 
Index: src/main/java/mil/navy/lcs/mvcs/common/model/NodeBuilder.java
===================================================================
--- src/main/java/mil/navy/lcs/mvcs/common/model/NodeBuilder.java	(revision 9620)
+++ src/main/java/mil/navy/lcs/mvcs/common/model/NodeBuilder.java	(working copy)
@@ -12,6 +12,7 @@
 
 import mil.navy.lcs.mvcs.common.config.ConfigManager;
 import mil.navy.lcs.mvcs.common.config.model.CircuitBreaker;
+import mil.navy.lcs.mvcs.common.config.model.CrossDomain;
 import mil.navy.lcs.mvcs.common.config.model.LanBypass;
 import mil.navy.lcs.mvcs.common.config.model.Radio;
 import mil.navy.lcs.mvcs.common.config.model.RadioQosProperties;
@@ -18,6 +19,9 @@
 import mil.navy.lcs.mvcs.common.config.model.VesselCommon;
 import mil.navy.lcs.mvcs.common.constants.HardwareConstants;
 import mil.navy.lcs.mvcs.common.constants.HardwareConstantsEnum;
+import mil.navy.lcs.mvcs.common.log.LoggingManager;
+import mil.navy.lcs.mvcs.iface.encryption.IPS250EncryptionDevice;
+import mil.navy.lcs.mvcs.iface.filter.FilterDevice;
 import mil.navy.lcs.mvcs.iface.model.node.CommsType;
 import mil.navy.lcs.mvcs.iface.model.node.HeartbeatData;
 import mil.navy.lcs.mvcs.iface.model.node.LinkModel;
@@ -48,11 +52,19 @@
       node.setNodeName(config.getName());
       node.addPowerDevices(getPowerDevices());
       node.addLinks(getLinks());
+      // add filter device (HAF-100) to the node
+      node.setFilterDevice(getFilterDevice());
 
       return node;
    }
 
 
+   /**
+    * To get the LAN and the radio links of the node. If radio uses an encryption device, the
+    * encryption device will get created here.
+    * 
+    * @return the collection of links in this node.
+    */
    private Collection<LinkModel> getLinks()
    {
       final Collection<LinkModel> links = new LinkedList<LinkModel>();
@@ -60,6 +72,7 @@
       final String rt1944Type = HardwareConstants.getConstant(HardwareConstantsEnum.RT1944);
       final String prc117Type = HardwareConstants.getConstant(HardwareConstantsEnum.PRC117);
       final String rt1988Type = HardwareConstants.getConstant(HardwareConstantsEnum.RT1988);
+      final String mcg101Type = HardwareConstants.getConstant(HardwareConstantsEnum.MCG101);
 
       links.add(createLanLink(config.getLanBypass()));
 
@@ -68,12 +81,14 @@
          final String type = radio.getLinkType();
          RadioLink radioLink = null;
 
-         if (rt1944Type.equals(type))
+         if (rt1944Type.equalsIgnoreCase(type))
             radioLink = createRT1944Link(radio);
-         else if (prc117Type.equals(type))
+         else if (prc117Type.equalsIgnoreCase(type))
             radioLink = createPRC117Link(radio);
-         else if (rt1988Type.equals(type))
+         else if (rt1988Type.equalsIgnoreCase(type))
             radioLink = createRT1988Link(radio);
+         else if (mcg101Type.equalsIgnoreCase(type))
+            radioLink = createMCG101Link(radio);
 
          if (radioLink != null)
          {
@@ -81,6 +96,21 @@
             links.add(radioLink);
          }
 
+         // add encryption device (IPS-250) if exists in the radio configuration
+         String encrypterType = radio.getEncrypterTypeId();
+         // IPS-250 is the only encryption device at this time.
+         if (encrypterType != null && encrypterType.equalsIgnoreCase(HardwareConstants.getConstant(HardwareConstantsEnum.IPS250)))
+         {
+            // get ID or Red side IP
+            String redIP = radio.getEncrypterRedIp();
+            if (redIP != null)
+            {
+               // IPS-250 is the only encryption device at this time.
+               IPS250EncryptionDevice ips250 = new IPS250EncryptionDevice(redIP, encrypterType);
+               radioLink.setEncryptionDevice(ips250);
+            }
+         }
+
       } // end of for(radios)
 
       return links;
@@ -131,6 +161,32 @@
 
 
    /**
+    * To get the filter device for the node using the mission configuration.
+    * 
+    * @return the filter device
+    */
+   private FilterDevice getFilterDevice()
+   {
+      FilterDevice filterDevice = new FilterDevice();
+      // Populate Filter device with it's settings
+      CrossDomain haf = config.getCrossDomain();
+
+      if (haf != null)
+      {
+         LoggingManager.getPrimaryLogger().debug("HAF found: " + haf.getName() + " " + haf.getIpAddress());
+         filterDevice.setFilterId(haf.getName());
+         filterDevice.setIpAddress(haf.getIpAddress());
+      }
+      else
+      {
+         LoggingManager.getPrimaryLogger().debug("HAF not found for this nodeId: " + node.getNodeId());
+      }
+
+      return filterDevice;
+   }
+
+
+   /**
     * To create LAN link.
     * 
     * @param lan - the LanBypass configurations
@@ -154,4 +210,7 @@
 
 
    abstract RadioLink createRT1988Link(Radio radio);
+
+
+   abstract RadioLink createMCG101Link(Radio radio);
 }
Index: src/main/java/mil/navy/lcs/mvcs/common/model/RmmvNodeBuilder.java
===================================================================
--- src/main/java/mil/navy/lcs/mvcs/common/model/RmmvNodeBuilder.java	(revision 9620)
+++ src/main/java/mil/navy/lcs/mvcs/common/model/RmmvNodeBuilder.java	(working copy)
@@ -7,7 +7,6 @@
 
 import com.google.common.collect.ImmutableMap;
 
-import mil.navy.lcs.mvcs.common.config.ConfigManager;
 import mil.navy.lcs.mvcs.common.config.model.Channel;
 import mil.navy.lcs.mvcs.common.config.model.Radio;
 import mil.navy.lcs.mvcs.common.config.model.VesselCommon;
@@ -166,8 +165,15 @@
    @Override
    protected RadioLink createRT1988Link(Radio radio)
    {
-      throw new RuntimeException("No RT1988 support for UUV");
+      throw new RuntimeException("No RT-1988 support for RMMV");
    }
 
 
+   @Override
+   RadioLink createMCG101Link(Radio radio)
+   {
+      throw new RuntimeException("No MCG-101 support for RMMV");
+   }
+
+
 }
Index: src/main/java/mil/navy/lcs/mvcs/common/model/ShipNodeBuilder.java
===================================================================
--- src/main/java/mil/navy/lcs/mvcs/common/model/ShipNodeBuilder.java	(revision 9620)
+++ src/main/java/mil/navy/lcs/mvcs/common/model/ShipNodeBuilder.java	(working copy)
@@ -181,4 +181,20 @@
 
       return new RadioLink(configRadio.getId(), node.getNodeId(), linkNumber, MvcsLinkType.RT1988, CommsType.SAT, power, ampPower, rfDevice, configRadio.getLosRange());
    }
+
+
+   @Override
+   RadioLink createMCG101Link(Radio radio)
+   {
+      final String radioId = radio.getId();
+      final int linkNumber = 0;
+
+      final PowerOutput power = node.getPowerDeviceForHardwareId(radioId).getOutputsByDeviceId().get(radioId);
+      power.setType(PowerOutputType.RADIO);
+
+      final Map<RFOutputType, PowerOutput> ampPower = Collections.emptyMap();
+      final RFDevice rfDevice = new RFDevice(radioId, MvcsLinkType.MCG101);
+
+      return new RadioLink(radio.getId(), node.getNodeId(), linkNumber, MvcsLinkType.MCG101, CommsType.SAT, power, ampPower, rfDevice, radio.getLosRange());
+   }
 }
Index: src/main/java/mil/navy/lcs/mvcs/common/model/UissNodeBuilder.java
===================================================================
--- src/main/java/mil/navy/lcs/mvcs/common/model/UissNodeBuilder.java	(revision 9620)
+++ src/main/java/mil/navy/lcs/mvcs/common/model/UissNodeBuilder.java	(working copy)
@@ -7,7 +7,6 @@
 
 import com.google.common.collect.ImmutableMap;
 
-import mil.navy.lcs.mvcs.common.config.ConfigManager;
 import mil.navy.lcs.mvcs.common.config.model.Radio;
 import mil.navy.lcs.mvcs.common.config.model.VesselCommon;
 import mil.navy.lcs.mvcs.common.constants.HardwareConstants;
@@ -51,7 +50,7 @@
    @Override
    protected RadioLink createRT1988Link(Radio radio)
    {
-      throw new RuntimeException("No RT1988 support for UUV");
+      throw new RuntimeException("No RT1988 support for USV");
    }
 
 
@@ -58,7 +57,7 @@
    @Override
    protected RadioLink createPRC117Link(Radio radio)
    {
-      throw new RuntimeException("No PRC117 support for UUV");
+      throw new RuntimeException("No PRC117 support for USV");
    }
 
 
@@ -118,4 +117,11 @@
 
       return rfDevice;
    }
+
+
+   @Override
+   protected RadioLink createMCG101Link(Radio radio)
+   {
+      throw new RuntimeException("No MCG-101 support for USV");
+   }
 }
Index: src/main/java/mil/navy/lcs/mvcs/common/model/UuvNodeBuilder.java
===================================================================
--- src/main/java/mil/navy/lcs/mvcs/common/model/UuvNodeBuilder.java	(revision 9620)
+++ src/main/java/mil/navy/lcs/mvcs/common/model/UuvNodeBuilder.java	(working copy)
@@ -67,4 +67,20 @@
    }
 
 
+   @Override
+   RadioLink createMCG101Link(Radio radio)
+   {
+      final String radioId = radio.getId();
+      final int linkNumber = radio.getLinkNumber();
+
+      final PowerOutput power = node.getPowerDeviceForHardwareId(radioId).getOutputsByDeviceId().get(radioId);
+      power.setType(PowerOutputType.RADIO);
+
+      final Map<RFOutputType, PowerOutput> ampPower = Collections.emptyMap();
+      final RFDevice rfDevice = new RFDevice(radioId, MvcsLinkType.MCG101);
+
+      return new RadioLink(radioId, node.getNodeId(), linkNumber, MvcsLinkType.MCG101, CommsType.SAT, power, ampPower, rfDevice, radio.getLosRange());
+   }
+
+
 }
Index: src/main/java/mil/navy/lcs/mvcs/common/radios/RadioPluginsManager.java
===================================================================
--- src/main/java/mil/navy/lcs/mvcs/common/radios/RadioPluginsManager.java	(revision 9620)
+++ src/main/java/mil/navy/lcs/mvcs/common/radios/RadioPluginsManager.java	(working copy)
@@ -81,20 +81,13 @@
  */
 public abstract class RadioPluginsManager implements IMvcsHardwareManager
 {
-   /**
-    * A hashtable holding the radio plugin instance with the radio name as the key to the entry
-    */
-   protected Hashtable<String, IRadioPlugin> pluginsHashTable;
+   /** A map holding the radio plug-in instance with the radio name as the key. */
+   protected Hashtable<String, IRadioPlugin> runtimePluginInstances;
 
-   /**
-    * An hashtable holding the radio plugin Java class name with the name of the radio as the key to
-    * the table
-    */
+   /** A map holding the radio plug-in Java class with the name of the radio as the key. */
+   protected Hashtable<String, String> radioNamesAndPluginClasses;
 
-   /** The list of */
-   protected Hashtable<String, String> radioNamesAndClassesHashTable;
 
-
    /** The hardware status of radios. */
    protected Hashtable<String, HardwareData> radioHardwareStatus;
 
@@ -106,8 +99,8 @@
     */
    public RadioPluginsManager()
    {
-      this.pluginsHashTable = new Hashtable<String, IRadioPlugin>();
-      this.radioNamesAndClassesHashTable = new Hashtable<String, String>();
+      this.runtimePluginInstances = new Hashtable<String, IRadioPlugin>();
+      this.radioNamesAndPluginClasses = new Hashtable<String, String>();
       this.radioHardwareStatus = new Hashtable<String, HardwareData>();
    }
 
@@ -114,53 +107,35 @@
 
    /**
     * 
-    * Method Description
+    * Add a radio name and a plug-in pair information to a map.
     * 
-    * Add a radio plugin information to the plugin name hashtable
-    * 
-    * @param radioPluginName the name of the radio plugin
-    * @param radioPluginClass the class of the radio plugin
+    * @param radioName the name of the radio. This is the key for the map.
+    * @param radioPluginClass the class of the radio plug-in
     * @return true of added successfully, false otherwise
     */
-   protected boolean addRadioPluginNameAndClass(String radioPluginName, String radioPluginClass)
+   protected boolean addRadioNameAndPluginClassPair(String radioName, String radioPluginClass)
    {
       try
       {
-         if (isNotNullOrBlank(radioPluginName) && isNotNullOrBlank(radioPluginClass))
+         if (isNotNullOrBlank(radioName) && isNotNullOrBlank(radioPluginClass))
          {
-            radioNamesAndClassesHashTable.put(radioPluginName, radioPluginClass);
+            radioNamesAndPluginClasses.put(radioName, radioPluginClass);
             return true;
          }
-         else
-            return false;
       }
       catch (Exception ex)
       {
-         LoggingManager.getPrimaryLogger().error("An exception occurred when adding " + radioPluginName + " to radioNamesHashTable hashtable");
-         return false;
+         LoggingManager.getPrimaryLogger().error("An exception occurred when adding " + radioName + " to the map.");
       }
 
+      return false;
    }
 
 
-   protected HardwareData getHardwareData(String radioName)
-   {
-      try
-      {
-         return this.radioHardwareStatus.get(radioName);
-      }
-      catch (Exception ex)
-      {
-         LoggingManager.getSystemErrorLogger().error("Error getting the hardware data for radio " + radioName);
-         return null;
-      }
-   }
-
-
    /**
     * 
-    * Method Description This method creates the HardwareData object to the hashtable. If a radio
-    * does not have configuration such as the Iridium, the setConfigured defaults to true
+    * This method creates the HardwareData object to the hash-table. If a radio does not have
+    * configuration such as the Iridium, the setConfigured defaults to true
     * 
     * @param radioName the name of the radio
     * @param radioType the type of the radio
@@ -193,61 +168,48 @@
 
    /**
     * 
-    * Method Description
+    * This method retrieve a plug-in instance by name. Note the argument is not the type of radio,
+    * ie. "RT-1944" but rather the name of a particular radio on the platform "RT1944-0" of the
+    * shipboard, "RT1944-1" of the vehicle 1, etc.
     * 
-    * @param radioPluginName
-    * @return
-    */
-   public String getRadioPluginClass(String radioPluginName)
-   {
-      return (String) radioNamesAndClassesHashTable.get(radioPluginName);
-   }
-
-
-   /**
-    * 
-    * Method Description
-    * 
-    * This method retrieve a plugin by name. Note the argument is not the type of radio, ie.
-    * "rmsVRC99" but rather the name of a particular radio on the platform "rmsVrc99-1" on
-    * Shipboard, "rmsVrc99-2" on Vehicle 1, etc.
-    * 
-    * @param radioPluginName the name of the radio for this particular plugin
+    * @param radioName the name of the radio for this particular plug-in
     * @return a IRadioPlugin object for a particular radio
     */
-   public IRadioPlugin getRadioPluginByName(String radioPluginName)
+   public IRadioPlugin getRadioPluginByName(String radioName)
    {
       try
       {
-         IRadioPlugin irp = (IRadioPlugin) pluginsHashTable.get(radioPluginName);
+         IRadioPlugin irp = (IRadioPlugin) runtimePluginInstances.get(radioName);
          return irp;
       }
       catch (Exception ex)
       {
-         LoggingManager.getPrimaryLogger().error("There was an error getting the radio plugin instance for " + radioPluginName);
+         LoggingManager.getPrimaryLogger().error("There was an error getting the radio plugin instance for radio:" + radioName);
          return null;
       }
    }
 
 
+   /**
+    * To get the collection of radio plug-in instance
+    * 
+    * @return
+    */
    public Collection<IRadioPlugin> getRadioPlugins()
    {
-      return pluginsHashTable.values();
+      return runtimePluginInstances.values();
    }
 
 
    /**
     * 
-    * Method Description Instantiate a radio plugin
-    * 
-    * @param pluginRadioName the name of the radio associated with this particular plugin
-    * @param pluginClassName the class to instantiate
-    * @return true of successful, false otherwsie
+    * To instantiate radio plug-ins and store the radio name and the plug-in pair in the plug-in
+    * map.
     */
    public void instantiatePlugins()
    {
-      Enumeration<String> e = radioNamesAndClassesHashTable.keys();
-      String pluginRadioName = "";
+      Enumeration<String> e = radioNamesAndPluginClasses.keys();
+      String radioName = "";
 
 
       while (e.hasMoreElements())
@@ -254,23 +216,23 @@
       {
          try
          {
-            // Take the name of a radio and get the name of the plugin class
-            pluginRadioName = (String) e.nextElement();
+            // Take the name of a radio and get the name of the plug-in class
+            radioName = e.nextElement();
 
+            // Get the class name of that particular plug-in and converts it to class name
+            String pluginClassName = radioNamesAndPluginClasses.get(radioName);
+            Class<?> newRadioClass = Class.forName(pluginClassName);
 
-            // Get the class name of that particular plugin and converts it to class name
-            Class<?> newRadioClass = Class.forName((String) radioNamesAndClassesHashTable.get(pluginRadioName));
-
+            LoggingManager.getPrimaryLogger().info("Initializing a plug-in:" + pluginClassName);
             // Use Reflection to instantiate the class
             final IRadioPlugin pluginInstance = (IRadioPlugin) newRadioClass.newInstance();
 
             // Put the plugin object in the pluginsHashTable hashtable
+            LoggingManager.getPrimaryLogger().info("adding plug-in for radio " + radioName + " to hashtable.");
+            runtimePluginInstances.put(radioName, pluginInstance);
 
-            LoggingManager.getPrimaryLogger().info("adding plugin " + pluginRadioName + " to hashtable ");
-            pluginsHashTable.put(pluginRadioName, pluginInstance);
-
             // Put in the plugin radio name for that particular plugin
-            pluginInstance.setRadioName(pluginRadioName);
+            pluginInstance.setRadioName(radioName);
 
             // This code is to get the list of all IP address needed to be managed by the
             // GUI. This includes all radios of the same type on the ship and
@@ -281,7 +243,7 @@
             if (ConfigManager.getInstance().isPrimaryVesselShip())
             {
                // This is the ship, so get all IP address for ship radios and vehicle radios
-               String radioType = getRadioTypeByName(pluginRadioName, true);
+               String radioType = getRadioTypeByName(radioName, true);
                List<Radio> radioList = ConfigManager.getInstance().getShip().getListOfRadios();
 
                // Get all the radios of the same type from the shipboard
@@ -319,7 +281,7 @@
             else
             {
                // This is a vehicle just get the IP address of the local agent(s)
-               String radioType = getRadioTypeByName(pluginRadioName, false);
+               String radioType = getRadioTypeByName(radioName, false);
                List<Radio> radioList = ConfigManager.getInstance().getVehicle().getListOfRadios();
 
                for (Radio r : radioList)
@@ -362,7 +324,7 @@
             // Find the SNMP agent IP address for this particular radio ID
             for (Radio r : radioList)
             {
-               if (r.getId().equalsIgnoreCase(pluginRadioName))
+               if (r.getId().equalsIgnoreCase(radioName))
                {
                   snmpIpAddress = r.getSnmpAgentIpAddress();
                   snmpPort = r.getSnmpAgentPortNumber();
@@ -370,7 +332,7 @@
                }
             }
 
-            LoggingManager.getPrimaryLogger().info("Setting radio ID " + pluginRadioName + " with IP address " + snmpIpAddress + " port " + snmpPort);
+            LoggingManager.getPrimaryLogger().info("Setting radio ID " + radioName + " with IP address " + snmpIpAddress + " port " + snmpPort);
 
             SnmpParameters snmpParameters = new SnmpParameters();
             snmpParameters.setSnmpIpAddress(snmpIpAddress);
@@ -379,8 +341,8 @@
          }
          catch (Exception ex)
          {
-            LoggingManager.getPrimaryLogger().error("An exception occurred when starting the Radio Plug-in Instance " + pluginRadioName);
-            pluginsHashTable.remove(pluginRadioName);
+            LoggingManager.getPrimaryLogger().error("An exception occurred when starting the Radio Plug-in Instance " + radioName);
+            runtimePluginInstances.remove(radioName);
             ex.printStackTrace();
          }
       }
@@ -472,18 +434,18 @@
       String pluginRadioName = "";
       try
       {
-         Enumeration<String> e = pluginsHashTable.keys();
+         Enumeration<String> e = runtimePluginInstances.keys();
          while (e.hasMoreElements())
          {
             pluginRadioName = (String) e.nextElement();
-            IRadioPlugin pi = (IRadioPlugin) pluginsHashTable.get(pluginRadioName);
+            IRadioPlugin pi = (IRadioPlugin) runtimePluginInstances.get(pluginRadioName);
             pi.stopPlugin();
             pi = null;
          }
-         pluginsHashTable.clear();
-         radioNamesAndClassesHashTable.clear();
-         pluginsHashTable = null;
-         radioNamesAndClassesHashTable = null;
+         runtimePluginInstances.clear();
+         radioNamesAndPluginClasses.clear();
+         runtimePluginInstances = null;
+         radioNamesAndPluginClasses = null;
       }
       catch (Exception ex)
       {
Index: src/main/java/mil/navy/lcs/mvcs/common/radios/interfaces/IRadioPlugin.java
===================================================================
--- src/main/java/mil/navy/lcs/mvcs/common/radios/interfaces/IRadioPlugin.java	(revision 9620)
+++ src/main/java/mil/navy/lcs/mvcs/common/radios/interfaces/IRadioPlugin.java	(working copy)
@@ -73,6 +73,11 @@
 public interface IRadioPlugin
 {
 
+   /**
+    * To set radio name
+    * 
+    * @param setRadioName - Sets the radio name
+    */
    public void setRadioName(String setRadioName);
 
 
@@ -82,12 +87,17 @@
    public boolean removeRadioPropertiesEventListener(IRadioProperties listener);
 
 
+   /** To start the plug-in */
    public void startPlugin();
 
 
+   /** To stop the plug-in */
    public void stopPlugin();
 
 
+   /**
+    * @return the radio name
+    */
    public String getRadioName();
 
 
Index: src/main/java/mil/navy/lcs/mvcs/common/utils/LinuxSystemUtils.java
===================================================================
--- src/main/java/mil/navy/lcs/mvcs/common/utils/LinuxSystemUtils.java	(revision 9620)
+++ src/main/java/mil/navy/lcs/mvcs/common/utils/LinuxSystemUtils.java	(working copy)
@@ -7,6 +7,7 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
+import java.net.InetAddress;
 
 import mil.navy.lcs.mvcs.common.log.LoggingManager;
 
@@ -65,4 +66,34 @@
 
       return output;
    }
+
+
+   /**
+    * To perform a ping to find whether the IP is reachable or not.
+    * 
+    * @param ipAddress - the IP address to test
+    * @return true if ipAddres is reachable
+    */
+   public static boolean ping(String ipAddress)
+   {
+      try
+      {
+         InetAddress inet = InetAddress.getByName(ipAddress);
+         LoggingManager.getPrimaryLogger().debug("Sending Ping Request to " + ipAddress);
+         if (inet.isReachable(5000))
+         {
+            LoggingManager.getPrimaryLogger().debug(ipAddress + " is reachable.");
+            return true;
+         }
+         else
+         {
+            LoggingManager.getPrimaryLogger().debug(ipAddress + " NOT reachable.");
+         }
+      }
+      catch (Exception e)
+      {
+         LoggingManager.getPrimaryLogger().error("Exception:" + e.getMessage());
+      }
+      return false;
+   }
 }
Index: src/main/java/mil/navy/lcs/mvcs/common/utils/PowerUtils.java
===================================================================
--- src/main/java/mil/navy/lcs/mvcs/common/utils/PowerUtils.java	(revision 9620)
+++ src/main/java/mil/navy/lcs/mvcs/common/utils/PowerUtils.java	(working copy)
@@ -1,50 +0,0 @@
-
-
-package mil.navy.lcs.mvcs.common.utils;
-
-
-import java.io.Serializable;
-
-/**
- * Class Description
- * <p>
- * Date Created: Sep 16, 2010
- * <p>
- * $LastChangedBy$ <br>
- * $LastChangedDate$ <br>
- * $LastChangedRevision$
- * 
- * @author username
- * @version 1.0
- */
-public class PowerUtils implements Serializable
-{
-   /** The serialized version ID. */
-   static final long serialVersionUID = 221L;
-
-   /**
-    * To get to power mode description.
-    * 
-    * @param powerConservationMode - the power conservation mode.
-    * @return - the power conservation mode description.
-    */
-   // public static String getPowerModeDescription(int powerConservationMode)
-   // {
-   // String powerModeDescription = "TBD";
-   // if (powerConservationMode == ConstantValues.VEHICLE_POWER_FULL_INDEX)
-   // powerModeDescription = ConstantValues.VEHICLE_POWER_FULL;
-   // else if (powerConservationMode == ConstantValues.VEHICLE_POWER_PARTIAL_INDEX)
-   // powerModeDescription = ConstantValues.VEHICLE_POWER_PARTIAL;
-   // else if (powerConservationMode == ConstantValues.VEHICLE_POWER_BATTERY_INDEX)
-   // powerModeDescription = ConstantValues.VEHICLE_POWER_BATTERY;
-   // else if (powerConservationMode == ConstantValues.VEHICLE_POWER_EXTERNAL_INDEX)
-   // powerModeDescription = ConstantValues.VEHICLE_POWER_EXTERNAL;
-   // else if (powerConservationMode == ConstantValues.VEHICLE_POWER_MULTIPLE_FAILSAFES_INDEX)
-   // powerModeDescription = ConstantValues.VEHICLE_POWER_MULTIPLE_FAILSAFES;
-   // else if (powerConservationMode == ConstantValues.VEHICLE_POWER_FAILSAFE_808_INDEX)
-   // powerModeDescription = ConstantValues.VEHICLE_POWER_FAILSAFE_808;
-   //
-   // return powerModeDescription;
-   // }
-
-}
Index: src/main/resources/mil/navy/lcs/mvcs/common/config/radio-type-characteristics.xml
===================================================================
--- src/main/resources/mil/navy/lcs/mvcs/common/config/radio-type-characteristics.xml	(revision 9620)
+++ src/main/resources/mil/navy/lcs/mvcs/common/config/radio-type-characteristics.xml	(working copy)
@@ -189,6 +189,33 @@
          </properties>
       </priority>
    </radioCharacteristics>
+
+   <radioCharacteristics>
+      <typeId>mcg101</typeId>
+      <radioType>MCG-101</radioType>
+      <radioImage>IridiumScu1_shadowed_px60.jpg</radioImage>
+      <appletName></appletName>
+      <emconCapable>false</emconCapable>
+      <othCapable>true</othCapable>
+      <lrCapable>true</lrCapable>
+      <missionCapable>true</missionCapable>
+      <frequencyType></frequencyType>
+      <pointToPoint>true</pointToPoint>
+      <linkQualityCapable>false</linkQualityCapable>
+      <maxLosRangeInNauticalMiles>10000</maxLosRangeInNauticalMiles>
+      <maxLrRangeInFeet>10000</maxLrRangeInFeet>
+      <maxAllowableTimeToStartInSec>180</maxAllowableTimeToStartInSec>
+      <maxAllowableTimeForManualPathSwitchInSec>180
+      </maxAllowableTimeForManualPathSwitchInSec>
+      <plugin>mil.navy.lcs.mvcs.plugins.mcg101.MCG101Plugin</plugin>
+      <heartbeatPort>0</heartbeatPort>
+      <priority>
+         <number>0</number>
+         <properties>
+            <label>0</label>
+         </properties>
+      </priority>
+   </radioCharacteristics>
    
 
 </radioCharacteristicsConfig>
Index: src/main/resources/mil/navy/lcs/mvcs/common/constants/hardware-constants.properties
===================================================================
--- src/main/resources/mil/navy/lcs/mvcs/common/constants/hardware-constants.properties	(revision 9620)
+++ src/main/resources/mil/navy/lcs/mvcs/common/constants/hardware-constants.properties	(working copy)
@@ -18,6 +18,7 @@
 iridium=Iridium SCU
 rt1988=RT-1988
 hfgw=HFGW
+mcg101=MCG-101
 kiv7=KIV-7M Encryptor
 lcs1=LCS 1
 lcs2=LCS 2
